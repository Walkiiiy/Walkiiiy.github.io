## 9.18
- arctic promptå¯¹é½ä¸å®Œå…¨ï¼Œschemaçš„é—®é¢˜ï¼Œaccè¿˜æ˜¯ä¸èƒ½å¤çº¿
- è®¨è®ºï¼šè’¸é¦deepseek/å¾®è°ƒqwen3 ï¼ˆå¯è€ƒè™‘å¤ç°Arctic?ï¼‰åšgeneratorï¼Œæ•ˆæœå®åœ¨ä¸è¡Œå†è°ƒapi
- ä¸è¡Œä¸­é—´éƒ¨åˆ†ç”¨å¤ç°çš„birdå¼€æºæ¨¡å‹

## 9.19
- qwen3 14båŸºå‡†æµ‹è¯•
- qwen3 8båŸºå‡†æµ‹è¯•
- åˆ†æArcticï¼šä¸ºä»€ä¹ˆè·‘ä¸é€š
- qwen3 8b generatorå¾®è°ƒ
- ç•¥è¯»sigmod text2sqlæ–‡çŒ®ï¼šä¸ä¸€å®šæå‡ºå¤æ‚method
- åˆ›æ–°ç‚¹ä¸å¤Ÿï¼šå¤šé˜…è¯»è®ºæ–‡ï¼Œç»“æ„å’Œæ–¹æ³•å¯ä»¥æ”¹
- å¹¶è¡Œï¼šè°ƒæ¨¡å‹ï¼Œä¼˜åŒ–åˆ›æ–°æ€§
- å®éªŒ:ä¸ä»…è¦è®¾è®¡ruleså¯¹æ¯”ï¼Œè¿˜è¦è®¾è®¡åŠ chainå’Œæ²¡æœ‰chainçš„å¯¹æ¯”
- åº”è¯¥æ˜¯ä»åå¾€å‰è®­ç»ƒï¼š
  - ç”Ÿæˆå¯ç”¨çš„generatorè®­ç»ƒææ–™ï¼šè‡ªç„¶è¯­è¨€æ­¥éª¤ã€‚å¾®è°ƒgeneratorç”Ÿæˆç›®æ ‡sqlèƒ½åŠ›
  - ç”¨è‡ªç„¶è¯­è¨€æ­¥éª¤åæ¨å®Œæ•´çš„é—®é¢˜è§£æï¼Œç”Ÿæˆå¯ç”¨çš„parserè®­ç»ƒææ–™ï¼Œå¾®è°ƒè®­ç»ƒparserç”Ÿæˆé—®é¢˜è§£æèƒ½åŠ›
  - ç”¨åæ¨å¾—åˆ°çš„ææ–™ï¼ˆé—®é¢˜è§£æå’Œè‡ªç„¶è¯­è¨€æ­¥éª¤ï¼‰å¾®è°ƒplannerç”Ÿæˆè‡ªç„¶è¯­è¨€æ­¥éª¤èƒ½åŠ›
  - æ•´ä½“æµ‹è¯•
- ç”Ÿæˆå¯ä»¥è€ƒè™‘ç”¨rules-extractionç±»ä¼¼æ–¹æ³•ï¼Œå¤šè½®æ¯”å¯¹æå–-æ”¹è¿›ï¼Œç¡®ä¿ç”Ÿæˆæ­£ç¡®å†…å®¹




## 9.20
- sql2plan prompt:
  ```
  You are a precise translator that converts an SQL query into a step-by-step natural-language execution plan.  
  Your job: given one SQL query, output a numbered list of steps describing exactly how to execute that query so someone (or another program) can reconstruct the SQL from the description. Accuracy is the top priority. The plan **must not use SQL keywords** (for example: select, from, where, join, group, having, order, limit, distinct, union, intersect, except, exists, in, subquery, alias, as) in the plan itself. Use only ordinary English and precise descriptions.

  Strict rules:
  1. Output only the numbered plan (one step per line). Do not include commentary, extraneous explanation, or the original SQL. If the SQL is invalid, output a single numbered step that clearly states the error in plain language.
  2. Preserve table and column names exactly as they appear in the SQL. When referencing them inside steps, put each name in square brackets like [table] or [table.column] so names remain unambiguous.
  3. If the query creates intermediate result sets (derived tables / nested queries), label them explicitly as "intermediate set 1", "intermediate set 2", etc., and describe exactly how each intermediate set is produced and what columns it contains.
  4. For filters, use exact logical conditions in plain English, e.g. "keep rows where [age] is greater than 30" or "keep rows where [status] is 'active' and [score] >= 80".
  5. For combining rows from multiple tables, describe the combination as: "combine rows from [A] and [B] where [A.col] equals [B.col]" and explicitly state the semantics:
    - If only matching pairs are kept, say: "keep only combinations that have a match in both sides."
    - If all rows from the left side are kept even when there is no match, say: "keep all rows from [left table]; when there is no matching row on the right, leave right-side columns empty."
    - If all rows from the right side are kept, describe symmetrically.
  6. For aggregation, avoid the phrase "group by". Instead say: "for each unique value of [column(s)] do the following: compute ..." and list aggregates precisely, e.g. "count of non-empty [id]" or "sum of [amount]" or "average of [duration]". If a filter applies to those aggregated results, say: "after computing those per-value results, keep only those groups where ...".
  7. For duplicate elimination, say: "remove duplicate rows so that values of [column list] are unique".
  8. For ordering and limiting, say: "sort the final rows by [column] from smallest to largest (or largest to smallest). Then take the first N rows" â€” be explicit about whether sorting happens before or after limiting.
  9. For computed columns or expressions, write the formula in plain math/word form, e.g. "create a new column named 'ratio' equal to [col_a] divided by [col_b]".
  10. For boolean logic, express it with plain words ("and", "or", "not") and use parentheses language if needed: "apply both conditions (A and B)".
  11. For correlated checks that depend on each row (existence checks), describe them as: "for each row in [X], check whether there exists at least one row in [Y] such that ...; keep those rows where the check succeeds."
  12. For set operations (union / intersect / except), describe them in plain terms: "produce rows that are present in either set A or set B (without duplicates)" or "produce rows present in A that are not present in B", etc.
  13. For window functions, describe partitioning and ordering in plain English and the computed window metric, e.g. "for each partition defined by [col], compute the running total of [amount] ordered by [date]" and whether the metric is attached to every row or only used for filtering.
  14. If query uses naming shortcuts (aliases), show both the original name and the shortcut once, e.g. "[employees] (called E)" and thereafter you may refer to the shortcut in square brackets like [E.id], but still preserve the link to the original.

  Output format example (must follow this style exactly):

  1. Start with all rows from [people].
  2. Keep only rows where [age] is greater than 30.
  3. For each remaining row, take the values of [name] and [age].
  4. Sort those rows by [age] from largest to smallest.
  5. Return the first 5 rows.

  Do not use any SQL keywords inside the steps. Be concise but exact. Now convert the SQL query below into the required plan (replace the SQL delimiter with the actual SQL):

  -----SQL START-----
  <PUT THE SQL QUERY HERE>
  -----SQL END-----
  ```
- å…ˆç”Ÿæˆæ²¡æœ‰ç‰¹æ®Štokençš„planåšgeneratorè®­ç»ƒï¼Œç„¶ååŠ å…¥tokens
- ä¹‹å‰çš„æ­£ç¡®ç‡ä½å¾ˆæœ‰å¯èƒ½æ˜¯å› ä¸ºLLMClient.chatæ²¡å†™å¥½

## 9.21
- åˆæˆæ•°æ®é›†ï¼šsql2text qwen3 8b
- å¦‚æœè¦åœ¨è®­ç»ƒæ–¹æ³•ä¸Šæœ‰åˆ›æ–°ï¼Œåˆ›æ–°ç‚¹éœ€è¦å¯¹text2sqlä»»åŠ¡æœ‰é’ˆå¯¹æ€§
- è¯»è¯»è®ºæ–‡
  - Dail-SQL ä¼˜åŒ–æ•°æ®é›†æ˜ å°„ï¼Œä½¿ç”¨ä¼˜åŒ–åçš„è®­ç»ƒé›†è®­ç»ƒå·²æœ‰çš„æ¨¡å‹ï¼Œç„¶ååœ¨ä¼˜åŒ–åçš„æµ‹è¯•é›†ä¸Šæµ‹è¯•ï¼Œæ¨¡å‹èƒ½åŠ›æå‡
  - 
- æ–¹æ¡ˆ1:è‡ªè®­ç»ƒ
- æ–¹æ¡ˆ2:GRPO
- æ–¹æ¡ˆ3:è°ƒapi
- æˆ–è€…æ”¹æ–¹æ¡ˆ



- ä¿®æ”¹ç»“æ„
- æ˜¯ä¸æ˜¯ä¸èƒ½æ‹¿Arcticæ¥æ”¹è¿›ï¼Ÿè¦æ„å»ºè‡ªå·±çš„ppe

- æŠŠparser-planner-excuteåˆå¹¶æˆä¸€ä¸ªæ¨¡å‹å…·ä½“è®­ç»ƒæ–¹æ³•ä»¿ç…§self-rag
  - å…·ä½“æ–¹æ¡ˆï¼š
  - æ˜¯å¦èƒ½è€ƒè™‘ä½¿ç”¨apiåˆæˆå°‘é‡è®­ç»ƒæ•°æ®
  - åˆ†ä¸ºä¸‰ä¸ªæ¨¡å‹çš„è®­ç»ƒé‡å¤ªå¤§ï¼Œè€Œä¸”å¯¹äºå°æ¨¡å‹æ¥è¯´æŠŠè®¡åˆ’å’Œæ‰§è¡Œåˆ†å¼€åè€Œä¼šé™ä½æˆåŠŸç‡ï¼Œäº‹å®ä¸ŠçŸ¥è¯†ç®€å•çš„sqlè½¬planå†è½¬å›sqlï¼ŒQwen3 8Båœ¨Birdä¸Šåªæœ‰40ä¸åˆ°çš„æˆåŠŸç‡ã€‚

## 9.22
- ä¹‹å‰æå‡ºçš„æ¶æ„å¤ªå¤§å¤ªåˆ†æ•£ï¼Œå¯¼è‡´éš¾ä»¥å®é™…è®­ç»ƒéƒ¨ç½²ï¼Œæ— ä»ä¸‹æ‰‹
- **åˆ›æ–°ç‚¹æ˜¯ç¼ºå°‘åœ¨motivationè¿˜æ˜¯è§£å†³æ–¹æ³•ï¼Ÿ**
  
- **motivation** åœ¨è¾“å…¥questionè¶³å¤Ÿæ˜ç¡®çš„å‰æä¸‹ï¼ŒLLMå¤§éƒ½èƒ½ç»™å‡ºæ­£ç¡®çš„æŸ¥è¯¢æ€è·¯ã€‚ä½†ç°æœ‰text2sqlä»å­˜åœ¨é—®é¢˜ï¼š
  - 1.**æ— æ³•ç†è§£questionçš„éšå«ä¿¡æ¯**ã€‚ä¼ ç»Ÿæ–¹æ³•é€šè¿‡ç»™question-sql pairåŠ ä¸Šä¸€å¥æ‰©å±•definationï¼ˆdefinational external knowledgeï¼Œä¹Ÿå°±æ˜¯Birdä¸­çš„evidenceï¼Œ A refers to Bï¼Œ C=...ï¼‰æ¥è§£å†³ï¼Œä½†æ˜¯**è¿™æå¤§å‰Šå¼±äº†å®é™…åº”ç”¨æ—¶çš„é²æ£’æ€§**
  - 2.questionç†è§£æ­£ç¡®ï¼ŒæŸ¥è¯¢æ€è·¯ä¹Ÿæ­£ç¡®ï¼Œä½†**æ‰§è¡Œæ–¹å¼ä¸é¢„æœŸä¸ç¬¦**ã€‚å¸¸è§çš„å°±æ˜¯å¿½ç•¥/ä¸è€ƒè™‘schemaçš„ç‰¹æ®Šç»“æ„ï¼Œä»¥å•ä¸€çš„ç»éªŒåŒ–æŸ¥è¯¢æ–¹å¼æ¥å†™sqlã€‚ä¼ ç»Ÿçš„è§£å†³æ–¹æ³•æ˜¯é€šè¿‡éšå¼çš„operational external knowledgeæå–ï¼š
    - ï¼ˆ1.schema-linkingï¼Œé€šè¿‡å‘é‡ç›¸ä¼¼åº¦/minhashç­‰ç®—æ³•ï¼Œç­›é€‰ç›¸å…³æ€§å¼ºçš„schemaä¿¡æ¯å’Œå…·ä½“å€¼æ¥è¾“å…¥ï¼Œçªå‡ºschemaé‡ç‚¹ç»“æ„ä¿¡æ¯ï¼Œä»éœ€è¦æ¨¡å‹è‡ªå·±æŒ–æ˜å‘ç°é‡ç‚¹ä¿¡æ¯
    - ï¼ˆ2.RAG-SQLï¼Œä»å¤§é‡exampleæ–‡æ¡£ä¸­æŠ½å–ç›¸ä¼¼ç¨‹åº¦é«˜çš„quesiton-sql pairï¼ŒåŠ å…¥promptä¾›æ¨¡å‹å­¦ä¹ ã€‚è¿™ç§æ–¹æ³•éå¸¸ä¾èµ–ç›¸ä¼¼æ€§ï¼Œç¼ºå°‘ç›¸ä¼¼sqlæˆ–è€…ç›¸ä¼¼åº¦æ¯”è¾ƒç®—æ³•éƒ½æ˜¯å…¶ç“¶é¢ˆ
    - ï¼ˆ3.æ¯”å¯¹å­¦ä¹ ã€åå¥½å­¦ä¹ ï¼Œå’Œæ–¹æ³•2ç±»ä¼¼ï¼ŒæŠ½å–ç›¸å…³æ€§å¼ºå’Œç›¸å…³æ€§å¼±çš„question-sqlå¯¹ï¼Œæ¥è®­ç»ƒæ¨¡å‹å‘é£æ ¼ç›¸ä¼¼çš„è¾“å‡ºé è¿‘ï¼Œå¹¶è¿œç¦»ç»“æ„ç›¸å¼‚çš„sqlè¾“å‡º
    **è€Œä¸”ä¸Šè¿°æ–¹æ³•éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„é—®é¢˜å°±æ˜¯å¯è§£é‡Šæ€§å¼±** 
  - 3. æ€è·¯å’Œæ‰§è¡Œæ–¹å¼éƒ½æ­£ç¡®ï¼Œä½†**æŸ¥è¯¢ç»“æœè¾“å‡ºçš„æ–¹å¼å’Œé£æ ¼ä¸é¢„æœŸä¸ç¬¦**ã€‚åœ¨ä¸¥æ ¼çš„æµ‹è¯•ç¯å¢ƒæˆ–è€…æŒ‘å‰”çš„ç”¨æˆ·èƒŒæ™¯ä¸‹ï¼Œè¿™æ ·çš„è¾“å‡ºå…¨éƒ¨åˆ¤é”™ã€‚ä»¥å¾€çš„ç ”ç©¶å¤šå¿½ç•¥è¿™ä¸€ç‚¹ï¼Œé‡ç‚¹è®­ç»ƒæ¨¡å‹æ ¹æ®questionå’Œschemaåˆ¶å®šæŸ¥è¯¢ç­–ç•¥ï¼Œå¿½ç•¥å…¶è¾“å‡ºå½¢å¼

- **contribution**
  - æå‡ºtext2sqlçš„å¯è§£é‡ŠNL rulesï¼Œå°†definationalå’Œoperationalçš„external knowledgeç»Ÿä¸€ä¸ºè‡ªç„¶è¯­è¨€è§„åˆ™
  - æå‡ºåŸºäºç›¸ä¼¼æ€§çš„å¯è§£é‡Šè§„åˆ™æ¨ç†æ¨¡å‹Rule Assumerï¼ˆè®­ç»ƒæ–¹æ³•åˆ›æ–°
  - ï¼ˆæå‡ºagenticè§„åˆ™éªŒè¯æ¨¡å—Rule Verifier
  - å®éªŒè¯æ˜å¯è§£é‡Šçš„ç»Ÿä¸€ç‰¹å¾æ¨ç†å¯ä»¥å¢å¼ºtext2sqlæ•ˆæœ

- **Methodology**
  - å›¾
  - å››ä¸ªæ¨¡å—ï¼šparse-plan-executor,definational_assumer,operational_assumer,verifier
  - é—®é¢˜ï¼šæœ€æœ‰è¯´æœåŠ›çš„æ¡†æ¶å’Œå®éªŒæ–¹å¼æ˜¯ä»€ä¹ˆ

- **Training**
  - parser-planner-executor
    - æ–¹æ¡ˆ1åˆ†å¼€è®­ç»ƒ
      - è‡ªè®­ç»ƒè¯­æ–™ç”Ÿæˆï¼šä»åå¾€å‰ä¾æ¬¡æ¨å¯¼ï¼šsql-->plan---ï¼ˆ+ question+ sqlï¼‰--->deteiled question
      - æ¯ä¸€æ­¥è¦ä¿è¯ç”Ÿæˆçš„planèƒ½è¢«è¿˜åŸä¸ºsqlï¼Œä½†æ˜¯ç›®å‰æ•ˆæœä¸ä½³
      - å¯ä»¥ç®€å•æ”¹è¿›ï¼Œè¯•è¯•è‡ªè®­ç»ƒ+å¾ªç¯çº é”™æ•ˆæœï¼Œä½†æ˜¯æ„Ÿè§‰æ„ä¹‰ä¸å¤§
      - åé¢è¿˜è¦åˆ†æå“ªäº›åœ°æ–¹æ’å…¥rulesï¼Œç”¨åˆ°äº†å“ªäº›rulesï¼Œæ·»åŠ ç‰¹æ®Štokenï¼ˆself-ragæ–¹æ³•ï¼‰ã€‚å¤§æ¦‚ç‡å¿…é¡»è¦apiè·å–è®­ç»ƒè¯­æ–™
    - æ–¹æ¡ˆ2
      - ä¸‰æ­¥å½“ä½œæ•´ä½“ä¸€èµ·è®­ï¼Œ å€Ÿé‰´Arcticå¼ºåŒ–å­¦ä¹ æ–¹æ³•ï¼Œéš¾åº¦å¤§ä¸ä¿è¯æ•ˆæœ
- **Experiment**




- rulesåˆ†ç±»ï¼šglobal rules å…³é”®è¯ï¼š quesiton calculate refer answering
- global Assumerè®­ç»ƒææ–™


## 9.23
- æµ‹è¯•golbalAssumer ä¸€è½®Spiderä¸‰è½®Bird 100æ¡ bird_dev
  - ğŸ“Š FINAL RESULTS:
  With Rules:
    Correct Answers: 33
    Failed Executions: 0
    Accuracy: 0.330 (33.0%)
  Without Rules:
    Correct Answers: 37
    Failed Executions: 0
    Accuracy: 0.370 (37.0%)

  ğŸ¯ IMPROVEMENT:
      Rules provide -0.040 (-4.0%) accuracy improvement
      âŒ Rules hurt performance!
- æµ‹è¯•globalAssumer ä¸€è½®Spiderä¸‰è½®Bird 100æ¡ bird_dev
  - 
  ```
  ğŸ“Š FINAL RESULTS:
  With SFT Rules:
    Correct Answers: 33
    Failed Executions: 0
    Accuracy: 0.330 (33.0%)
  With Dataset Rules:
    Correct Answers: 55
    Failed Executions: 0
    Accuracy: 0.550 (55.0%)
  Without Rules (Baseline):
    Correct Answers: 33
    Failed Executions: 0
    Accuracy: 0.330 (33.0%)

  ğŸ¯ IMPROVEMENTS:
    SFT Rules vs No Rules: +0.000 (+0.0%)
    Dataset Rules vs No Rules: +0.220 (+22.0%)
    SFT Rules vs Dataset Rules: -0.220 (-22.0%)

  ğŸ† ANALYSIS:
      â– SFT rules have no effect on performance
      âœ… Dataset rules help improve performance over baseline!
      ğŸ“š Dataset rules perform better than SFT rules!      
      ```
- æµ‹è¯•ä¸­assumed ruleså‡ºé”™è€Œè‡ªå¸¦ruleså¯¹çš„sampleï¼š
  ```
  Database: toxicology
Question: List all carcinogenic molecules and their elements.
Ground Truth: SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'

ğŸ¤– Step 1: Generating rules with fine-tuned model...
Generated Rules:
Rule 1:
Condition: When the question asks for elements of molecules
Operation: use "T1.element" from the "atom" table instead of "element" from the "molecule" table.

ğŸ“‹ Step 2: Extracting dataset definitional rules...
Dataset Rules:
Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "T2.label = '+'" in schema.

Condition: When the question mentions "carcinogenic"
Operation: use T2.label = '+' as the condition for carcinogenic molecules

Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "molecule label = '+' in schema".

Condition: When answering about "carcinogenic molecules and their elements"
Operation: make sure the output order: T2.molecule_id, T1.element

Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "T2.label = '+' in schema"

Condition: When the question asks for "distinct molecules"
Operation: compute the number of unique values of T2.molecule_id

Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "label in schema" with values like '+' and '-'.
  ``` 
  ```
  Sample 91/100
  Database: california_schools
  Question: For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?
  Ground Truth: SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1

  ğŸ¤– Step 1: Generating rules with fine-tuned model...
  Generated Rules:
  Rule 1:
  Condition: When the question asks for the school with the highest average score in Reading
  Operation: use the "AvgScrRead" column from the "satscores" table to determine the highest score.

  ğŸ“‹ Step 2: Extracting dataset definitional rules...
  Dataset Rules:
  Condition: When answering about "school with the highest average score in Reading"
  Operation: rank schools by T1.AvgScrRead in descending order and keep the first 1 row.

  Condition: When the question asks for "FRPM count for students aged 5-17"
  Operation: use the exact column T2."FRPM Count (Ages 5-17)" instead of FRPM_5_17.
  ```
  ```
  ğŸ¤– Step 1: Generating rules with fine-tuned model...
  Generated Rules:
  Rule 1:
  Condition: When the question asks for race dates
  Operation: select "date" from the "races" table instead of "race_date" from "formula_1".

  ğŸ“‹ Step 2: Extracting dataset definitional rules...
  Dataset Rules:
  Condition: When answering about Formula 1 race dates on Barcelona-Catalunya circuit
  Operation: make sure the output order: T2.date

  Condition: When the question mentions "Barcelona-Catalunya circuit"
  Operation: "Barcelona-Catalunya" actually means "T1.name = 'Circuit de Barcelona-Catalunya'" in schema
  ```

- æ”¹è¿›ï¼šè®­ç»ƒæ—¶å»æ‰æ²¡æœ‰definational rulesçš„æ•°æ®
- å¯ä»¥å…ˆè¯•è¯•ç”¨qwen å‡ç¼©definational rulesï¼Œä¾¿äºä½œä¸ºlableã€‚ä¸ç„¶lableé•¿åº¦ä¸ä¸€å®šè€Œä¸”å«æœ‰é‡å¤å¤§é‡æ— ç”¨çš„ä¿¡æ¯



## 9.24
- condensed rules å®éªŒ bird-train 100æ¡æ•°æ®ï¼Œ dataset ruleså³ä¸ºcondensed rulesï¼š
```
ğŸ“Š FINAL RESULTS:
  With SFT Rules:
    Correct Answers: 42
    Failed Executions: 0
    Accuracy: 0.420 (42.0%)
  With Dataset Rules:
    Correct Answers: 59
    Failed Executions: 0
    Accuracy: 0.590 (59.0%)
  Without Rules (Baseline):
    Correct Answers: 46
    Failed Executions: 0
    Accuracy: 0.460 (46.0%)

ğŸ¯ IMPROVEMENTS:
  SFT Rules vs No Rules: -0.040 (-4.0%)
  Dataset Rules vs No Rules: +0.130 (+13.0%)
  SFT Rules vs Dataset Rules: -0.170 (-17.0%)
```

## 9.25
- 10epoch bird train global assumeræ•ˆæœä»æ—§ä¸ä½³ï¼šbird_devæµ‹è¯•ï¼š
```
ğŸ“Š FINAL RESULTS:
  With SFT Rules:
    Correct Answers: 29
    Failed Executions: 0
    Accuracy: 0.290 (29.0%)
  With Dataset Rules:
    Correct Answers: 61
    Failed Executions: 0
    Accuracy: 0.610 (61.0%)
  Without Rules (Baseline):
    Correct Answers: 32
    Failed Executions: 0
    Accuracy: 0.320 (32.0%)

ğŸ¯ IMPROVEMENTS:
  SFT Rules vs No Rules: -0.030 (-3.0%)
  Dataset Rules vs No Rules: +0.290 (+29.0%)
  SFT Rules vs Dataset Rules: -0.320 (-32.0%)

ğŸ† ANALYSIS:
    âŒ SFT rules hurt performance compared to baseline!
    âœ… Dataset rules help improve performance over baseline!
    ğŸ“š Dataset rules perform better than SFT rules!
```
- æµ‹è¯•100æ¡æ•°æ®ï¼Œå…¶ä¸­æœ‰9æ¡æ˜¯ä¸å¸¦ruleså’Œè‡ªå¸¦ruleså¯¹ï¼Œæ¨ç†rulesé”™ï¼š
```
   "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
      "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
      "db_id": "california_schools",

      "generated_rules": 
      "Rule 1:\nCondition: When answering about 'highest eligible free rate for K-12 students' and the question mentions 'Alameda County'\n
      Operation: use the exact column token 'Percent (%) Eligible Free (K-12)' from table frpm, and filter using the exact literal 'Alameda County' on column County Name from table schools.",

      "dataset_rules": 
      "Condition: When answering about \"highest eligible free rate for K-12 students\"\n
      Operation: calculate Free Meal Count (K-12) divided by Enrollment (K-12) instead of selecting a pre-calculated free_rate column.\n\n
      Condition: When the question mentions \"schools\"\n
      Operation: query from table \"frpm\" instead of \"schools\".\n\n
      Condition: When the question mentions \"schools\"\n
      Operation: use \"schools AS T1\" as the base table.",

      "sql_with_sft_rules": "SELECT MAX(frpm.`Percent (%) Eligible Free (K-12)`) FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.County = 'Alameda County';",
      "sql_without_rules": "SELECT MAX(\"Percent (%) Eligible Free (K-12)\") FROM frpm WHERE \"County Name\" = 'Alameda';",
      "sql_with_dataset_rules": "SELECT MAX(\"Free Meal Count (K-12)\" / \"Enrollment (K-12)\") FROM frpm AS T1 WHERE \"County Name\" = 'Alameda';",
   
   é”™è¯¯åŸå› ï¼šgenerated rulesåˆ—åé”™


   "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
      "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
      "db_id": "thrombosis_prediction",

      "generated_rules": "Rule 1:\nCondition: When the question asks about 'underage patients' and specifies a three-year period from 1990 to 1993\n
      Operation: filter using T1.Birthday to identify patients under 3 years old and use T2.`Examination Date` between '1990-01-01' and '1993-12-31' to capture all examinations within the three-year period.",

      "dataset_rules": 
      "Condition: When answering about underage patients examined during 1990-1993\n
      Operation: join Patient as T1 with Examination as T2 using T1.ID = T2.ID to link patient records with their examinations.",
      
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT T1.ID) FROM Patient T1 JOIN Examination T2 ON T1.ID = T2.ID WHERE T1.Birthday >= DATE('1990-01-01', '-3 years') AND T2.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31';",
      "sql_without_rules": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE e.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31' AND (julianday(e.`Examination Date`) - julianday(p.Birthday)) / 365.25 < 18;",
      "sql_with_dataset_rules": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31' AND (julianday(T2.`Examination Date`) - julianday(T1.Birthday)) / 365.25 < 18;",
    


     "sample_idx": 29,
      "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
      "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Risky'",
      "db_id": "european_football_2",
      "generated_rules": "Rule 1:\nCondition: When the question asks for football teams with a specific 'chance creation passing class' and specifies 'short name only'\nOperation: use the exact column token 'T1.short_name' from the Team table, and filter using the exact literal 'Riski' instead of 'Risk' for the 'chance_creation_passing_class' column.",
      "dataset_rules": "Condition: When answering about football teams with chance creation passing class\nOperation: join Team as T1 and Team_attributes as T2 where T1.team_api_id = T2.team_api_id to properly relate team attributes.",
      "sql_with_sft_rules": "SELECT T1.team_short_name FROM Team AS T1 JOIN Team_Attributes AS TA ON T1.team_api_id = TA.team_api_id WHERE TA.chanceCreationPassingClass = 'Riski';",
      "sql_without_rules": "SELECT DISTINCT t.team_short_name FROM Team t JOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id WHERE ta.chanceCreationPassingClass = 'Risky';",
      "sql_with_dataset_rules": "SELECT T1.team_short_name FROM Team AS T1 JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.chanceCreationPassingClass = 'Risky';",
     

     "sample_idx": 31,
      "question": "Please state the reference name of the oldest German driver.",
      "ground_truth": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
      "db_id": "formula_1",
      "generated_rules": "Rule 1:\nCondition: When answering about 'the oldest German driver'\nOperation: use T3.nation = 'Germany' to filter by nationality, order by T1.birthDate in ascending order to find the earliest birth date, and use T1.forename and T1.surname to construct the full name.",
      "dataset_rules": "Condition: When the question asks for \"reference name\"\nOperation: select the exact column \"driverRef\" from the drivers table.\n\nCondition: When the question asks for \"reference name\"\nOperation: select the exact column \"driverRef\" from the drivers table.\n\nCondition: When the question asks for \"reference name\" of a driver\nOperation: use the exact column token \"driverRef\" from the drivers table instead of \"name\".",
      "sql_with_sft_rules": "SELECT driverRef FROM drivers WHERE nationality = 'Germany' ORDER BY dob ASC LIMIT 1;",
      "sql_without_rules": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1;",
  


   "sample_idx": 50,
      "question": "How many clients who were born in 1920 stay in east Bohemia?",
      "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
      "db_id": "financial",
      "generated_rules": "Rule 1:\nCondition: When referencing columns\nOperation: always qualify column references with table aliases (e.g., T1.column_name), use exact column names like 'DeliveryDate' and 'OrderNumber' instead of generic terms, and use unqualified column names like 'ContainerType' and 'PurchaseDate' when explicitly instructed.\n\nRule 2:\nCondition: When the question asks about clients born in 1920 and staying in east Bohemia\nOperation: filter using T1.birth_date = '1920-01-01' and T2.district_id = 1 to represent the year 1920 and the specific district ID for east Bohemia, respectively.",
      "dataset_rules": "Condition: When the question mentions \"clients\"\nOperation: use table \"client AS T1\" and join with \"district AS T2\" using INNER JOIN district AS T2 ON T1.district_id = T2.district_id.",
      "sql_with_sft_rules": "SELECT COUNT(DISTINCT T1.client_id) FROM client T1 JOIN district T2 ON T1.district_id = T2.district_id WHERE T1.birth_date = '1920-01-01' AND T2.district_id = 1;",
      "sql_without_rules": "SELECT COUNT(DISTINCT c.client_id) FROM client c JOIN district d ON c.district_id = d.district_id WHERE strftime('%Y', c.birth_date) = '1920' AND d.A3 = 'east Bohemia';",
      "sql_with_dataset_rules": "SELECT COUNT(*) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE strftime('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia';",
   


   "sample_idx": 52,
      "question": "Which element is the least numerous in non-carcinogenic molecules?",
      "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
      "db_id": "toxicology",
      "generated_rules": "Rule 1:\nCondition: When answering about 'least numerous element in non-carcinogenic molecules'\nOperation: Ensure the output order is element name first, then count. Rank elements by COUNT(T1.atom_id) in ascending order and keep the first 1 row. 'Non-carcinogenic' means T2.carcinogenic = 'FALSE' in the schema.",
      "dataset_rules": "Condition: When answering about \"least numerous element in non-carcinogenic molecules\"\nOperation: make sure the output order: T.element only.",
      "sql_with_sft_rules": "SELECT a.element, COUNT(a.atom_id) FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.carcinogenic = 'FALSE' GROUP BY a.element ORDER BY COUNT(a.atom_id) ASC LIMIT 1;",
      "sql_without_rules": "SELECT a.element FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label != 'carcinogenic' GROUP BY a.element ORDER BY COUNT(*) ASC LIMIT 1;",
      "sql_with_dataset_rules": "SELECT a.element FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label != 'carcinogenic' GROUP BY a.element ORDER BY COUNT(*) ASC LIMIT 1;",
     


     "sample_idx": 63,
      "question": "In superheroes with weight less than 100, list the full name of the superheroes with brown eyes.",
      "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'",
      "db_id": "superhero",
      "generated_rules": "Rule 1:\nCondition: When the question asks for 'full name'\nOperation: If the question specifies 'brown eyes', use the exact column token 'T1.full_name' instead of combining first_name and last_name. Otherwise, use the exact column token 'full_name' from the superhero table.",
      "dataset_rules": "Condition: When answering about superheroes with weight less than 100 and brown eyes\nOperation: use table alias T1 for superhero table and T2 for colour table.",
      "sql_with_sft_rules": "SELECT T1.full_name FROM superhero AS T1 JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'brown';",
      "sql_without_rules": "SELECT s.full_name FROM superhero s JOIN colour c ON s.eye_colour_id = c.id WHERE s.weight_kg < 100 AND c.colour = 'Brown';",
      "sql_with_dataset_rules": "SELECT T1.full_name FROM superhero T1 JOIN colour T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown';",
    


    "sample_idx": 72,
      "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
      "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
      "db_id": "california_schools",
      "generated_rules": "Rule 1:\nCondition: When the question asks for zip codes of charter schools\nOperation: select \"T2\".\"zip_code\" from the \"projects\" table instead of \"zip_code\" from the \"schools\" table.",
      "dataset_rules": "Condition: When answering about charter schools in Fresno County Office of Education\nOperation: use \"T2.Zip\" instead of \"zip_code\" for the zip code output.\n\nCondition: When the question asks for charter schools in a specific county office of education\nOperation: filter rows where \"District Name\" exactly matches the specified county office name like 'Fresno County Office of Education'.",
      "sql_with_sft_rules": "SELECT DISTINCT T2.zip_code FROM schools JOIN projects AS T2 ON schools.CDSCode = T2.CDSCode WHERE schools.County = 'Fresno' AND schools.District = 'Fresno County Office of Education' AND schools.Charter = 1;",
      "sql_without_rules": "SELECT DISTINCT s.Zip FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.County = 'Fresno' AND f.`Charter School (Y/N)` = 1 AND f.`District Name` = 'Fresno County Office of Education';",
      "sql_with_dataset_rules": "SELECT T2.Zip FROM frpm JOIN schools AS T2 ON frpm.CDSCode = T2.CDSCode WHERE frpm.`District Name` = 'Fresno County Office of Education' AND frpm.`Charter School (Y/N)` = 1;",
   


   "sample_idx": 76,
      "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
      "ground_truth": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
      "db_id": "card_games",
      "generated_rules": "Rule 1:\nCondition: When answering about cards that are promotional paintings with multiple faces\nOperation: Ensure the output order is based on T1.name, and the query should include T1.name in the SELECT list.",
      "dataset_rules": "Condition: When the question asks for cards that are promotional\nOperation: filter using \"isPromo = 1\" instead of string matching on type.\n\nCondition: When the question asks for cards with multiple faces\nOperation: filter using \"side IS NOT NULL\" instead of numeric comparison on face_count.",
      "sql_with_sft_rules": "SELECT DISTINCT T1.name FROM cards T1 WHERE T1.isPromo = 1 AND T1.layout LIKE '%split%' AND T1.faceName IS NOT NULL ORDER BY T1.name;",
      "sql_without_rules": "SELECT DISTINCT c.name FROM cards c WHERE c.isPromo = 1 AND c.otherFaceIds IS NOT NULL AND c.otherFaceIds != '';",
      "sql_with_dataset_rules": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL;",
    
```






- å†æ¬¡æµ‹è¯•
```
Sample 9 - Database: student_club
Question: Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.
Ground Truth: SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about students with hometown information
Operation: select from "member" AS T1 instead of "students" table.

Condition: When the question mentions "hometown of Lincolnton, North Carolina"
Operation: use T2.city = 'Lincolnton' and T2.state = 'North Carolina' instead of hometown filtering.

Condition: When the question mentions "zip code of 28092"
Operation: use T2.zip_code = 28092 (numeric value) instead of string comparison.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks for full name
Operation: Combine the first_name and last_name columns to form the complete name. If the table contains a 'full_name' column, use it directly; otherwise, concatenate first_name and last_name. If the position is required, select 'T2.position' from the 'position' table.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT first_name || ' ' || last_name AS full_name, position FROM member WHERE zip = 28092;
With dataset rules: SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;
Without rules: SELECT m.first_name, m.last_name, m.position FROM member m JOIN zip_code z ON m.zip = z.zip_code WHERE z.city = 'Lincolnton' AND z.short_state = 'NC' AND z.zip_code = 28092;

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)




Sample 10 - Database: california_schools
Question: Please list the phone numbers of the schools with the top 3 SAT excellence rate.
Ground Truth: SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC LIMIT 3

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about "phone numbers of schools with top SAT excellence rate"
Operation: make sure the output order: T1.Phone.

Condition: When the question mentions "top 3"
Operation: rank rows by the excellence rate in descending order and keep the first 3 rows.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks for phone numbers
Operation: select the exact column 'phone' from the 'client' table (T1) if the context refers to clients, or select the exact column 'phone' from the 'customer' table if the context refers to customers. If the context refers to schools, select the 'phone' column from the 'schools' table.

Rule 2:
Condition: When the question mentions 'SAT excellence rate'
Operation: this refers to the 'AvgScrMath' column in the 'satscores' table.

Rule 3:
Condition: When the question asks for 'top 3' by a metric
Operation: rank rows by the relevant metric in descending order and keep the first 3 rows. If the metric is 'SAT excellence rate', use 'AvgScrMath' from the 'satscores' table. If the metric is 'score', use the 'score' column from the 'scores' table. If the metric is 'medal count', compute the sum of medals per country and rank by that sum.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT s.phone FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds ORDER BY sat.AvgScrMath DESC LIMIT 3;
With dataset rules: SELECT s.Phone FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds ORDER BY CAST(sat.NumGE1500 AS REAL) / sat.NumTstTakr DESC LIMIT 3;
Without rules: SELECT s.Phone FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds WHERE sat.NumTstTakr > 0 ORDER BY CAST(sat.NumGE1500 AS REAL) / sat.NumTstTakr DESC LIMIT 3;

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)





Sample 17/100 - student_club
2025-09-25 10:27:43,836 - Process_model.SQLTestComparator - ERROR - Error executing predicted SQL: SELECT COUNT(*) FROM major AS T1 JOIN budget AS T2 ON T1.major_id = T2.link_to_major WHERE T1.college = 'College of Agriculture and Applied Sciences' AND T1.department = 'School of Applied Sciences, Technology and Education';, no such column: T2.link_to_major
2025-09-25 10:27:47,673 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:27:51,930 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 17 - Database: student_club
Question: In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?
Ground Truth: SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about majors in a specific college and department
Operation: query the "major" table instead of the "departments" table.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When answering about majors in a specific college and department
Operation: join major table as T1 with budget table as T2 using T1.major_id = T2.link_to_major to access the normalized schema structure.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT COUNT(*) FROM major AS T1 JOIN budget AS T2 ON T1.major_id = T2.link_to_major WHERE T1.college = 'College of Agriculture and Applied Sciences' AND T1.department = 'School of Applied Sciences, Technology and Education';
With dataset rules: SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';
Without rules: SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)




2025-09-25 10:29:37,200 - Process_model.SQLTestComparator - ERROR - Error executing predicted SQL: SELECT COUNT(*) FROM Post JOIN users ON Post.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie' AND Post.ParentId IS NULL;, no such table: Post
2025-09-25 10:29:41,701 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:29:46,439 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 23 - Database: codebase_community
Question: Among the posts owned by csgillespie, how many of them are root posts?
Ground Truth: SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about posts owned by a specific user
Operation: join the posts table (T1) with the users table (T2) where T1.OwnerUserId equals T2.Id to correctly link posts to users.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When referencing the posts table
Operation: use the exact table name 'Post' instead of 'posts' to match the schema.

Rule 2:
Condition: When the question asks about posts owned by a specific user
Operation: join the posts table (T1) with the users table (T2) using T1.OwnerUserId = T2.Id to establish the ownership relationship.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT COUNT(*) FROM Post JOIN users ON Post.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie' AND Post.ParentId IS NULL;
With dataset rules: SELECT COUNT(*) FROM posts JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie' AND posts.ParentId IS NULL;
Without rules: SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie') AND ParentId IS NULL;

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)




2025-09-25 10:30:58,457 - Process_model.SQLTestComparator - WARNING - SQL results do not match
2025-09-25 10:31:02,223 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:31:05,634 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 27 - Database: card_games
Question: Name the cards that were illustrated by Aaron Boyd.
Ground Truth: SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When the question asks for card names
Operation: use the exact column "name" from the cards table instead of "card_name".

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks for cards illustrated by a specific artist
Operation: join the cards table (T1) with the illustrations table (T2) using T1.id = T2.card_id to connect cards to their illustrators.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT DISTINCT c.name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Illustrator' AND fd.name = 'Aaron Boyd';
With dataset rules: SELECT name FROM cards WHERE artist = 'Aaron Boyd';
Without rules: SELECT name FROM cards WHERE artist = 'Aaron Boyd';

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)





2025-09-25 10:34:46,490 - Process_model.SQLTestComparator - WARNING - SQL results do not match
2025-09-25 10:34:49,715 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:34:53,157 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 39 - Database: card_games
Question: How many card border with black color ? List out the card id.
Ground Truth: SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When the question asks for card border with black color
Operation: use the exact literal value 'black' for the borderColor filter condition.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks for "card border with black color"
Operation: filter for rows where "borderColor" equals exactly 'Black' (not 'black') and select the "id" column.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT id FROM cards WHERE borderColor = 'Black';
With dataset rules: SELECT id FROM cards WHERE borderColor = 'black';
Without rules: SELECT id FROM cards WHERE borderColor = 'black';

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)






Sample 48/100 - card_games
2025-09-25 10:37:27,582 - Process_model.SQLTestComparator - WARNING - SQL results do not match
2025-09-25 10:37:31,190 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:37:37,333 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 48 - Database: card_games
Question: Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.
Ground Truth: SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When the question asks about sets with expansion type 'Commander'
Operation: filter sets where "type" equals 'commander' exactly (case-sensitive).

Condition: When the question asks for the set with highest total number of cards including promotional and related supplemental products
Operation: order sets by "totalSetSize" in descending order and take the first result.

Condition: When the question asks to indicate the id of the set
Operation: select only the "id" column from the sets table.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks about sets with expansion type Commander and the set with the highest total number of cards
Operation: filter using T1.type = 'Commander' from the sets table, order by T1.totalSetSize DESC and take the first row.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT id FROM sets WHERE type = 'Commander' ORDER BY totalSetSize DESC LIMIT 1;
With dataset rules: SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;
Without rules: SELECT s.id FROM sets s JOIN cards c ON s.code = c.setCode WHERE s.type = 'commander' AND c.availability NOT LIKE '%alchemy%' GROUP BY s.id ORDER BY COUNT(c.id) DESC LIMIT 1;

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)




2025-09-25 10:38:13,831 - Process_model.SQLTestComparator - WARNING - SQL results do not match
2025-09-25 10:38:18,331 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:38:27,250 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 50 - Database: financial
Question: What is the amount of debt that client number 992 has, and how is this client doing with payments?
Ground Truth: SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about client debt and payment status
Operation: select T4.amount and T4.status instead of aggregating with SUM and COUNT functions.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks about 'amount of debt' for a specific client or 'how is this client doing with payments'
Operation: For 'amount of debt', calculate the sum of 'ol_amount' from table 'order' where 'ol_accountkey' equals the client's account number. For 'payment history', include 'trans_date' and 'amount' from table 'trans' to show payment timing and amounts.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT (SELECT SUM(amount) FROM `order` o JOIN disp d ON o.account_id = d.account_id WHERE d.client_id = 992) AS debt_amount, t.date AS payment_date, t.amount AS payment_amount FROM trans t JOIN disp d ON t.account_id = d.account_id WHERE d.client_id = 992 AND t.type = 'DEBIT' ORDER BY t.date;
With dataset rules: SELECT loan.amount, loan.status FROM loan JOIN disp ON loan.account_id = disp.account_id WHERE disp.client_id = 992;
Without rules: SELECT l.amount AS debt_amount, l.status AS payment_status FROM loan l JOIN disp d ON l.account_id = d.account_id WHERE d.client_id = 992;

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)





2025-09-25 10:38:36,755 - Process_model.SQLTestComparator - ERROR - Error executing predicted SQL: SELECT AVG(long_shot) FROM Goalies WHERE firstName = 'Ahmed' AND middleName = 'Samir' AND lastName = 'Farag';, no such table: Goalies
2025-09-25 10:38:46,514 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:38:52,382 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 51 - Database: european_football_2
Question: Find the average number of long-shot done by Ahmed Samir Farag.
Ground Truth: SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about "average number of long-shot done by Ahmed Samir Farag"
Operation: make sure the output order: calculate average manually using SUM(t2.long_shots) divided by COUNT(t2.date) with CAST to REAL instead of using AVG function.

Condition: When the question mentions "long-shot"
Operation: "long-shot" actually means "t2.long_shots" in schema from the Player_Attributes table.

Condition: When the question mentions "Ahmed Samir Farag"
Operation: "Ahmed Samir Farag" actually means filtering by t1.player_name = 'Ahmed Samir Farag' exactly as written.

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When answering about 'average number of long-shot done by Ahmed Samir Farag'
Operation: use table 'Goalies' instead of 'players', filter using 'firstName = 'Ahmed' AND middleName = 'Samir' AND lastName = 'Farag' instead of a single player_name field, and use column 'long_shot' instead of 'long_shots'.

ğŸ” SQL COMPARISON:
With SFT rules: SELECT AVG(long_shot) FROM Goalies WHERE firstName = 'Ahmed' AND middleName = 'Samir' AND lastName = 'Farag';
With dataset rules: SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.date) FROM Player t1 JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag';
Without rules: SELECT AVG(pa.long_shots) FROM Player_Attributes pa JOIN Player p ON pa.player_api_id = p.player_api_id WHERE p.player_name = 'Ahmed Samir Farag';

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)




2025-09-25 10:39:21,733 - Process_model.SQLTestComparator - ERROR - Error executing predicted SQL: SELECT T3.college FROM member JOIN major ON member.link_to_major = major.major_id JOIN institution_details AS T3 ON major.major_id = T3.major_id WHERE member.first_name = 'Katy' AND member.link_to_major = 'rec1N0upiVLy5esTO';, no such table: institution_details
2025-09-25 10:39:27,857 - Process_model.SQLTestComparator - INFO - SQL results match!
2025-09-25 10:39:32,801 - Process_model.SQLTestComparator - INFO - SQL results match!

================================================================================
ğŸ” SPECIAL CASE: Fine-tuned model failed while others succeeded
================================================================================
Sample 53 - Database: student_club
Question: Please indicate the college of the person whose first name is Katy with the link to the major "rec1N0upiVLy5esTO".
Ground Truth: SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.link_to_major = 'rec1N0upiVLy5esTO' AND T1.first_name = 'Katy'

ğŸ“‹ EXTRACTED RULES (from dataset):
Condition: When answering about "college of the person whose first name is Katy with link to major 'rec1N0upiVLy5esTO'"
Operation: make sure the output order: T2.college

Condition: When the question mentions "person"
Operation: "person" actually means "member table (T1) in schema"

Condition: When the question mentions "college"
Operation: "college" actually means "college column in major table (T2) in schema"

ğŸ¤– GENERATED RULES (from fine-tuned model):
Rule 1:
Condition: When the question asks for college information
Operation: use "T3.college" from the "institution_details" table instead of "college" from "students".

ğŸ” SQL COMPARISON:
With SFT rules: SELECT T3.college FROM member JOIN major ON member.link_to_major = major.major_id JOIN institution_details AS T3 ON major.major_id = T3.major_id WHERE member.first_name = 'Katy' AND member.link_to_major = 'rec1N0upiVLy5esTO';
With dataset rules: SELECT T2.college FROM member T1 JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Katy' AND T1.link_to_major = 'rec1N0upiVLy5esTO';
Without rules: SELECT m.college FROM member JOIN major m ON member.link_to_major = m.major_id WHERE member.first_name = 'Katy' AND member.link_to_major = 'rec1N0upiVLy5esTO';

âŒ ERROR ANALYSIS:
Fine-tuned model SQL is incorrect (result: 0)
Dataset rules SQL is correct (result: 1)
No rules SQL is correct (result: 1)





ç»“æœï¼š

ğŸ“Š FINAL RESULTS:
  With SFT Rules:
    Correct Answers: 22
    Failed Executions: 0
    Accuracy: 0.220 (22.0%)
  With Dataset Rules:
    Correct Answers: 64
    Failed Executions: 0
    Accuracy: 0.640 (64.0%)
  Without Rules (Baseline):
    Correct Answers: 35
    Failed Executions: 0
    Accuracy: 0.350 (35.0%)

ğŸ¯ IMPROVEMENTS:
  SFT Rules vs No Rules: -0.130 (-13.0%)
  Dataset Rules vs No Rules: +0.290 (+29.0%)
  SFT Rules vs Dataset Rules: -0.420 (-42.0%)

ğŸ† ANALYSIS:
    âŒ SFT rules hurt performance compared to baseline!
    âœ… Dataset rules help improve performance over baseline!
    ğŸ“š Dataset rules perform better than SFT rules!

Results saved to: /home/ubuntu/walkiiiy/ChatTB/sft_triple_comparison_results.json
2025-09-25 10:56:57,840 - __main__ - INFO - Results saved to /home/ubuntu/walkiiiy/ChatTB/sft_triple_comparison_results.json

```


- åˆ†æåŸå› å¾ˆå¯èƒ½æ˜¯å› ä¸ºdefinationalæ•°æ®æœ¬èº«è´¨é‡ä¸é«˜
- å‡å¦‚è®©æ¨¡å‹æå–definational å’Œ operational ruleså‘¢
  - è¦æ±‚åˆ†å¼€definationalå’Œoperationalï¼Œ
  - è¦æ±‚conditionå’Œoperationä¸€ä¸€å¯¹åº”ï¼Œæ‰€æœ‰ç›¸ä¼¼çš„conditionåˆå¹¶æˆä¸€æ¡pair
  - å»æ‰åŒ–åT1 T2è¿™ç§

- å¾®è°ƒå…³é”®è¯åŠ æƒ å‰ç½®å·¥ä½œï¼š



- è®ºæ–‡å…ˆä»æ–¹æ³•å†™
- å…ˆæå¥½assumer
- deepspeed zero3 qwen30b
- 



## 9.26

- Spider_train loss on Bird_train
  - 5040 0.9356
  - 4000 0.9245
  - 3000 0.8317
  - 2000 0.8545
- Spider_train_Bird_train loss on Bird_dev
  -  1000 1.0514
  -  2000 1.037
  -  3000 1.08
  -  4000 1.12


## 9.27
- Assumeræ€è·¯ï¼š
  - 
  - 
- 8b Assumer_Mixed Loss test on Bird_dev:
  - 1000 steps: 0.6015
  - 2000 steps: 0.5085
  - 3000 steps: 0.4559
  - 4000 steps 0.4222
  - 5000 steps 0.3795
  - 6000 steps 0.3420
  - 7000 steps 0.3159
  - 8000 steps 0.2916
  - 9000 steps 0.2646
  - 10000 0.2305 
  - 11000 0.2155
  - 12000 0.2038
  - 13000 0.2023

- åœ¨sqlæµ‹è¯•ä¸­ç”Ÿæˆçš„rulesä¸ture rulesåœ¨å¥å­ç»“æ„ä¸Šå·²ç»éå¸¸ç›¸ä¼¼ï¼Œå¤šæ•°æƒ…å†µä¸‹åªæœ‰ç»†èŠ‚å¤„ç†æ–¹å¼ä¸Šä¸åŒ
- å’Œseedå¾ˆåƒï¼Œä½†æ˜¯æˆ‘ä»¬é¢˜ç›®æ›´å¤§ï¼Œä¸ç”¨dsæˆ–gptè€Œæ˜¯è‡ªå·±è®­assumerï¼Œè€Œä¸”æ•°æ®é›†æ›´å¼±ï¼ˆå¼±åŒ–Spiderï¼‰

- global-assumerå¾ˆæœ‰æ•ˆæœï¼Œå…ˆtry all meanså°½åŠ›æå‡global assumerçš„acc
  

## 9.28
- token mimic SFTï¼š
  - é¿å…æ¨¡å‹åœ¨æ•´ä½“æ€è·¯æ­£ç¡®çš„æƒ…å†µä¸‹å› ä¸ºrulesçš„å¾®å°é”™è¯¯å¯¼è‡´sqlæ¨ç†é”™è¯¯
  - è¾“å…¥çš„æ•°æ®è¿˜æ˜¯condensed_rules.json
  - å…ˆç”¨SFTçš„æŒ‡å®šæ¨¡å‹Aè¿›è¡Œrule inference
  - æ‹†è§£æˆä¸€æ¡æ¡rule
  - å¯¹äºç”Ÿæˆçš„æ¯ä¸€æ¡ruleï¼Œå’Œæ•°æ®é›†ä¸­è¯¥æ•°æ®çš„æ¯ä¸€æ¡ruleè¿›è¡Œembeddingç›¸ä¼¼åº¦è®¡ç®—
  - å–ç›¸ä¼¼åº¦æœ€å¤§ä¸”å¤§äº0.7çš„ä¸€æ¡ruleï¼Œè®©æ¨¡å‹Båœ¨å°è¯•åœ¨ä¿®æ”¹å°½å¯èƒ½å°çš„æ¡ä»¶ä¸‹ï¼Œä½¿rule1è¾¾åˆ°å’Œrule2ç›¸åŒçš„æ•ˆæœï¼Œè¾“å‡ºä¿®æ”¹åçš„rule3
  - å¦‚æœæ‰€æœ‰ç›¸ä¼¼åº¦å°äº0.7ï¼Œä¸è¿›è¡Œä»»ä½•æ“ä½œ
  - å°†ä¿®æ”¹åçš„rule3æ›¿ä»£rule1åˆ°ç¬¬ä¸€è½®è¾“å‡ºçš„rulesä¸­ï¼Œå†è¿›è¡Œä¸€è½®æ¨ç†ï¼Œå¹¶å°†ä¿®æ”¹åçš„rulesä½œä¸ºlableå¯¹æ¨¡å‹Aè¿›è¡Œå¾®è°ƒå¹¶æŠŠlossè°ƒå¤§
  - 

```


## 9.29

- æ—¶é—´è§„åˆ’
  - å®éªŒæ—¶é—´è§„åˆ’ï¼š
    - ç›®å‰è®­ç»ƒçš„global assumeråœ¨å…¶ä»–å¼€æºtext2sqlæ¨¡å‹ä¸Šå®éªŒï¼Œå·²ç»å–å¾—æ•ˆæœ
    - 10.8å‰å®ç°è‡ªå·±çš„sqlç”Ÿæˆéƒ¨åˆ†å’Œlocal assumer
    - å®éªŒå·²ç»è¯æ˜æ ¸å¿ƒæ–¹æ³•æœ‰æ•ˆï¼Œå…ˆæŠŠå‰©ä¸‹çš„å…¨å®ç°äº†å†ä¼˜åŒ–ex
  - è®ºæ–‡æ—¶é—´è§„åˆ’ï¼š
    - ç›®å‰å†™äº†ä¸€ç‚¹introductionå’Œapproaché‡Œçš„è®­ç»ƒé›†rulesåˆæˆæ–¹æ³•
    - 10.8å‰å†™related workså’Œapproachçš„æ•´ä½“æ¶æ„å¹¶ç”»å›¾


- motivationå’Œåˆ›æ–°ç‚¹
  - é’ˆå¯¹**é¢˜ç›®ä¸å¤Ÿå¤§**çš„é—®é¢˜ï¼Œæå‡ºæ–°çš„æƒ³æ³•ï¼š
```markdown
  text2sqlçš„è¾“å…¥natural language question(NLQ)**è´¨é‡æ™®éå¤ªå¼º**ï¼Œä¸å…¶åˆè¡·â€œä½¿ä¸äº†è§£schemaç»“æ„å’Œsqlè¯­å¥çš„æ™®é€šç”¨æˆ·ä¹Ÿèƒ½æ‰§è¡ŒæŸ¥è¯¢â€ä¸ç¬¦
  
  æˆ‘ä»¬**å¯¹ä¼ ç»ŸNLQè¾“å…¥è¿›è¡Œå¼±åŒ–**ï¼Œä¸**æ™®é€šç”¨æˆ·åœºæ™¯**ä¸‹èƒ½è¾¾åˆ°çš„è¾“å…¥è´¨é‡å¯¹é½ï¼š
    å¯¹ä¸Birdæ•°æ®é›†ï¼Œä¸è¾“å…¥evidence
    å¹¶ä¸”å¯¹Birdå’ŒSpiderçš„NLQè¿›è¡Œæ¨¡ç³Šå¤„ç†
  åœ¨æ­¤è¾“å…¥ä¸‹ï¼Œå¯¹å·²æœ‰çš„text2sqlæ–¹æ³•è¿›è¡Œæµ‹è¯•ï¼Œexå¤§å¤§é™ä½ï¼Œè¿™è¯å®äº†æˆ‘ä»¬çš„è§‚ç‚¹

  ä¸ºæ­¤æˆ‘ä»¬æå‡ºäº†**åœ¨å¼±NLQè¾“å…¥æ¡ä»¶ä¸‹ä»èƒ½é«˜è´¨é‡ç”ŸæˆSQL**çš„æ–¹æ³•: **rules-assuming** structure
  ....
```
- rules exä¼˜åŒ–æƒ³æ³•
- æ¨ªå‘é—®é¢˜