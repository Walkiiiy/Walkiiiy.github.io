## 12.6
- 论文与理论证明1建模维度数量n
    - 仿照R&B引力1，理论证明建模质量会影响配方质量，因此维度数算法会影响建模质量会影响配方质量
    - 原Lemma1：交换两簇内元素能提升多少配比效果（后悔值）由簇内一致性和簇间不一致性（聚类质量）决定
    - 目标lemma：操作s下，label策略能提升多少

## 12.8
- gradient receipe p1 思路
    - challenge：如何构建高质量能力空间，如何以模型学习能力、目标相关度进行投影，如何保证梯度的协同性、有效性
    - 为了解决challenge1，必须先考虑什么是高质量的能力空间
    - 假设能力空间的质量由目标贴合度和明确度决定，就必须证明贴合度和明确度会直接影响到配方效果，才能为后面的构建方法提供理论依据
    - lemma1 提出假设并证明贴合度和明确度直接影响到配方效果
    - 接下来就是怎么保证贴合度和明确度，即和抽象的微调目标尽可能接近，且使用尽量简洁的建模维度
    - 明确度： 
    - 贴合度：



    - 凭空捏词比较忌讳，“能力空间”这种应该由已有术语跟进
        - 确实被提出过，CDT提出了能力空间，但是没有研究能动态构建“能力空间”
        - 许多工作都做过类似能力空间的工作，但是术语不统一
    - 落实是否有已有的工作做过类似以贴合度和明确度作为指标构建能力空间的工作


    - 选一个最有代表性的能力空间平替

    - 问题：统筹局部配方策略构成的pipeline成为一个独立操作


    - 没有办法改“能力空间”，因为只有在向量空间中才能
    - 没有研究明确提出“能力空间”
    - 最相似的是“能力框架”
    - 





## 12.15
- Ros实验

## 12.16
- docker中从源码安装一遍ros2 foxy

## 12.21
- ROS
  - 源码dockerfile，保存后使用docker build -t ros2-humble-src . 构建：
    ```dockerfile
    FROM ubuntu:22.04

    # ========= 基本环境 =========
    ENV DEBIAN_FRONTEND=noninteractive
    ENV LANG=en_US.UTF-8
    ENV LC_ALL=en_US.UTF-8

    # ========= 换源（HTTP bootstrap，规避 TLS/CA 问题） =========
    RUN sed -i 's@http://archive.ubuntu.com@http://mirrors.tuna.tsinghua.edu.cn@g' /etc/apt/sources.list && \
        sed -i 's@http://security.ubuntu.com@http://mirrors.tuna.tsinghua.edu.cn@g' /etc/apt/sources.list && \
        sed -i '/jammy-updates/d' /etc/apt/sources.list

    # ========= 基础系统依赖 =========
    RUN apt-get update && apt-get install -y \
        ca-certificates \
        locales \
        curl \
        wget \
        git \
        build-essential \
        cmake \
        ninja-build \
        python3 \
        python3-pip \
        python3-setuptools \
        python3-wheel \
        python3-argcomplete \
        lsb-release \
        gnupg2 \
        && locale-gen en_US.UTF-8 \
        && rm -rf /var/lib/apt/lists/*

    # ========= 切回 HTTPS =========
    RUN sed -i 's@http://mirrors.tuna.tsinghua.edu.cn@https://mirrors.tuna.tsinghua.edu.cn@g' /etc/apt/sources.list

    # ========= 添加 OSRF / Gazebo 仓库（无 software-properties-common） =========
    RUN mkdir -p /usr/share/keyrings && \
        curl -fsSL https://packages.osrfoundation.org/gazebo.key | \
        gpg --dearmor -o /usr/share/keyrings/gazebo-archive-keyring.gpg && \
        echo "deb [arch=amd64 signed-by=/usr/share/keyrings/gazebo-archive-keyring.gpg] \
    https://packages.osrfoundation.org/gazebo/ubuntu-stable jammy main" \
        > /etc/apt/sources.list.d/gazebo-stable.list

    # ========= ROS Python 工具链（统一 pip） =========
    RUN python3 -m pip install --upgrade pip && \
        pip3 install \
        empy==3.3.4 \
        colcon-common-extensions \
        rosdep \
        vcstool \
        catkin_pkg \
        rosdistro

    # ========= 初始化 rosdep =========
    RUN rosdep init || true
    RUN rosdep update

    # ========= ROS2 Workspace =========
    WORKDIR /ros2_ws

    # ========= 拉取 ROS 2 Humble 源码 =========
    RUN mkdir -p src && \
        curl -fsSL https://raw.githubusercontent.com/ros2/ros2/humble/ros2.repos -o ros2.repos && \
        vcs import src < ros2.repos && \
        rm ros2.repos

    # ========= rosdep 安装系统依赖（最终稳定 skip 集） =========
    RUN apt-get update && \
        rosdep install \
        --from-paths src \
        --ignore-src \
        --rosdistro humble \
        -y \
        --skip-keys "fastcdr rti-connext-dds-6.0.1 urdfdom_headers \
                    python3-vcstool \
                    python3-colcon-common-extensions \
                    python3-rosdep \
                    python3-catkin-pkg-modules \
                    python3-rosdistro-modules" && \
        rm -rf /var/lib/apt/lists/*

    # ========= 默认进入 bash =========
    CMD ["/bin/bash"]


    # 构建后进入ros目录运行：
    # colcon build   --merge-install   --parallel-workers 2   --cmake-args     -DBUILD_TESTING=OFF
    ```

  - 有专门的编译模块colcon，不能使用g++编译
  - C++入口库rcl_cpp,python入口库rcl，其中rcl_cpp单独构建：
    ```
    # 一步到位构建 rclcpp 及其所有依赖
    cd /ros2_ws

    # 方法1：使用 --packages-up-to（最简单）
    colcon build --packages-up-to rclcpp \
    --merge-install \
    --parallel-workers 2 \
    --cmake-args -DBUILD_TESTING=OFF

    # 方法2：分模块构建（更可控）
    # 步骤1：构建基础
    colcon build --packages-up-to ament_cmake_ros

    # 步骤2：构建通信层
    colcon build --packages-up-to rmw_implementation

    # 步骤3：构建rcl层
    colcon build --packages-up-to rcl

    # 步骤4：构建rclcpp
    colcon build --packages-select rclcpp
    ```
    用时6分半，119个包，全部构建要300+包，18分钟
  - 本质是一个进程通信系统，主要提供三种进程通信方式：
  - | 特性 | 话题(Topic) | 服务(Service) | 动作(Action) |
    |------|-------------|---------------|--------------|
    | 通信模式 | 发布-订阅 | 请求-响应 | 目标-反馈-结果 |
    | 同步性 | 异步 | 同步 | 异步（有同步部分） |
    | 数据流 | 单向流式 | 一次性双向 | 长期双向 |
    | 实时性 | 实时推送 | 等待响应 | 持续反馈 |
    | 适用场景 | 传感器数据 | 开关控制 | 导航任务 |
    | 示例 | 速度命令 | 生成海龟 | 旋转到角度 |

  - 其中消息服务动作分别用.msg,.srv,.action 文件来定义传递的数据结构
  - fuzz候选模块：
    - rosidl_adapter 这个包用来对接口定义文件如.msg进行检查规范
    - rosidl_adapter/rosidl_generator_c 这个包将将接口定义文件转为c语言结构体和函数，生成c头文件
- paper


## 12.24
- paper
  -  不同评判标准的组合方式
     -        正确性    相关性    难易度      有效梯度    目标
  -  文学       
  -  莎士比亚
  -  物理
  -  相对论

  - 众包 弱监督回归
  - 假如说，映射全部使用模型或低成本计算方法实现？
  - 随便。反正现在不是讨论方法，假设已经有很完美的映射打分
  - p4方法: 各种打分维度汇总成一个，然后所有能力维度用汇总模型汇总成一个向量，这个向量与本条数据被训练的权重相关，然后用上下文比对学习得到训练效果，训练效果通过强化学习奖励信号反馈给汇总模型更新参数
  - 以往方法都注重数据评测角度，忽略能力维度的发掘
  - 横轴的评测维度，纵轴的能力维度，都要有权重，用强化学习训练，还要有理论推导，其中纵轴的权重就是目标能力配比（目标模型在空间中的额位置），可以是死的（指定或模型预测），也可以用验证集找最佳能力配比

## 12.25
- 关键在与能力领域的比例关系
- 多目标强化学习，1是使能力领域权重合适，2是使打分维度权重合适
- 理论证明可以来自，当没有验证集时，使用来自统一分布的数据构成的特定数据集，同样可以收敛（否决
- 目标能力配比以聚类完成后的簇大小比例（数据量）结合用户意图给模型推断，用户指定为准
- 或者不映射，就从各种组合的训练效果中推导一条数据的最终梯度
- 由于数据量大，使用上下文学习看训练效果
- 算法问题抽象成：从怎样的数据组合中怎样计算得到每一条数据每一个能力的最终数值
- 使用预训练模型做推理，分为使用验证集和不使用验证集的两种方法
- 不使用验证集时，自己做交叉验证，只更新数据权重，不参数实际训练过程，不用担心污染
- 理论证明：性能下界？
- 贡献值
  - 