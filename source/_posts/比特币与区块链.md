---
title: 比特币与区块链
date: 2025-03-10 13:34:08
tags:
---
## 区块链Blockchain
### **区块（Block）**
在比特币网络中，**区块（Block）** 就像是一本账本上的一页，它记录了一定时间内发生的所有**比特币交易**，并通过密码学技术保证数据的完整性、安全性和不可篡改性。区块按照时间顺序链接在一起，形成一条**区块链（Blockchain）**。

---
### **区块头（Block Header）**
区块头是比特币区块的核心部分，每个区块的头部大约 80 字节，包含以下重要字段：

| **字段**        | **描述** |
|----------------|---------|
| **前一区块哈希（Prev Block Hash）** | 指向上一个区块的哈希值，确保区块链的连贯性。 |
| **Merkle 根（Merkle Root）** | 通过哈希树（Merkle Tree）计算出的所有交易的摘要。 |
| **时间戳（Timestamp）** | 记录区块被创建的时间（Unix 时间戳）。 |
| **难度目标（Difficulty Target）** | 当前区块挖矿的难度系数。 |
| **随机数（Nonce）** | 矿工用来进行工作量证明（PoW）的数值。 |


---

### **区块体（Block Body）**
区块体存储该区块中所有交易数据。比特币网络的每个区块最多可容纳 **1MB** 数据，通常能存放 **2000-3000 笔交易**。

| **交易信息** | **描述** |
|-------------|---------|
| **交易 ID（TXID）** | 交易的唯一标识，由交易数据哈希计算得出。 |
| **交易输入（Inputs）** | 交易来源，即使用哪些 UTXO（未花费交易输出）。 |
| **交易输出（Outputs）** | 交易的目标地址和金额。 |
| **交易签名（Signature）** | 交易发起人（发送者）的数字签名，确保交易的真实性。 |

---


### **区块的生成（挖矿过程）**
比特币区块的生成方式是**挖矿（Mining）**，本质上是矿工在全网竞争解决一个数学难题，即计算区块的 **PoW（工作量证明）**，找到符合要求的哈希值。

##### **步骤**
1. **矿工收集交易数据**  
   - 矿工从比特币网络中获取**未确认交易**，并将其打包到新区块中。
   - 计算所有交易的 Merkle 根，存入区块头。

2. **计算区块哈希（工作量证明）**  
   - 矿工需要找到一个 **Nonce**（随机数），使得：
     ```
     SHA-256(区块头) < 目标难度
     ```
   - 例如：
     ```
     0000000000000000000abc12345...
     ```
     这个哈希值前面必须有足够数量的 0。

3. **成功挖矿后广播区块**  
   - 其他矿工和节点验证新区块的哈希值、交易是否合法。
   - 验证通过后，区块被加入比特币区块链，交易正式生效。

---

## 交易

### **比特币的诞生（挖矿过程）**
比特币的诞生主要依赖于 **工作量证明（PoW, Proof of Work）**，也就是“挖矿”。比特币的挖矿过程就是矿工（计算机）竞争解决一道数学难题，谁先找到解，谁就能创建新的区块，并获得比特币奖励。

#### **生成新的区块**
假设你是一个比特币矿工，你想要挖出一个新区块，必须做如下工作：

1. **收集未确认的交易**  
   - 你从比特币网络中收集所有用户提交的交易（比如 Alice 向 Bob 发送 1 BTC）。
   - 这些交易会被打包到一个新区块中。

2. **构造 Merkle 树（Merkle Tree）**  
   - 把所有交易的哈希值计算出来，比如：
     ```
     TX1 = SHA-256(交易1)
     TX2 = SHA-256(交易2)
     ```
   - 继续对哈希值进行两两组合计算，最终得到一个唯一的 **Merkle 根（Merkle Root）**，这个根会被存入区块头。

3. **计算区块哈希**
   - 区块头包括：
     - 上一个区块的哈希值
     - 本区块的 Merkle 根
     - 时间戳
     - 难度目标
     - 一个随机数 **Nonce**
   - 你要不断调整 **Nonce**，使得：
     ```
     SHA-256(区块头) < 目标难度
     ```
   - 例如：
     ```
     00000000000000000006b9b9d3c9e5c7eac4c4f8e25fc27b0a2...
     ```
     这个哈希值开头有足够数量的 0（难度目标设定的）。

4. **成功挖矿后，广播新区块**
   - 当你找到符合难度要求的哈希值，你就能把这个新区块广播到全网。
   - 其他节点验证区块是否合法（包括哈希值、交易有效性）。
   - 通过后，区块加入比特币区块链。

5. **矿工奖励**
   - 你作为矿工，会获得 **新生成的比特币（区块奖励）+ 交易手续费** 作为奖励。
   - 目前区块奖励约 **6.25 BTC**（每四年减半）。

---

### **比特币交易过程**
现在，假设 Alice 挖到了一些比特币，并想转账 1 BTC 给 Bob。比特币交易是基于 **UTXO（未花费交易输出）** 机制的，涉及 **数字签名、哈希函数、公私钥加密** 等密码学技术。

#### **交易创建**
Alice 要创建一笔交易，过程如下：

1. **获取未花费的 UTXO**
   - Alice 查询自己钱包中所有未花费的比特币交易记录（UTXO）。
   - 例如，她找到一个以前收到的 2 BTC UTXO。

2. **构造交易数据**
   - 交易数据包括：
     - **输入（Input）**：以前的 UTXO
     - **输出（Output）**：
       - 1 BTC 发给 Bob
       - 0.99 BTC 找零（扣除 0.01 BTC 作为矿工费）

   - 交易格式：
     ```
     Inputs:
       - TXID: (Alice 以前收到的 2 BTC 交易哈希)
       - ScriptSig: Alice 的数字签名 + 公钥

     Outputs:
       - 1 BTC -> Bob 的公钥哈希
       - 0.99 BTC -> Alice 的公钥哈希（找零）
     ```

3. **使用 Alice 的私钥进行签名**
   - Alice 用她的私钥 **d_A** 生成交易的数字签名：
     ```
     签名 = Sign(d_A, SHA-256(交易数据))
     ```
   - 这确保：
     - **只有 Alice 可以花费这个 UTXO**（因为只有她有私钥）。
     - **任何人都可以验证签名的正确性**（使用 Alice 的公钥）。

4. **广播交易**
   - Alice 将这笔交易广播到比特币网络。

---

#### **交易验证**
比特币网络中的矿工和节点会验证 Alice 的交易是否合法：

1. **检查 UTXO 是否未被使用**
   - 矿工会查询比特币账本，确保 Alice 之前的 UTXO 还没有被花费。

2. **验证 Alice 的签名**
   - 使用 Alice 的公钥 P_A 验证：
     ```
     Verify(P_A, 签名, SHA-256(交易数据)) == True
     ```
   - 如果签名有效，证明 Alice 确实是 UTXO 的所有者。

3. **检查交易格式**
   - 确保交易金额大于 0，矿工费符合规则。

4. **交易进入内存池（Mempool）**
   - 交易通过验证后，会进入矿工的“交易池”，等待被打包进新区块。

---

#### **交易被矿工打包**
- 当矿工打包新区块时，会选取 **手续费较高** 的交易优先处理（矿工更愿意打包高手续费的交易）。
- 交易被加入 Merkle 树，并最终进入新的区块。

---

#### **交易确认**
Bob 需要等待交易被矿工“确认”：
- **1 次确认**：交易进入最新的区块。
- **6 次确认**：后续 6 个新区块都建立在这个区块之后（较为安全）。

当 Bob 看到交易已被多个区块确认，他就可以放心地认为自己已经真正收到了 1 BTC。

**节点分为轻节点和全节点,轻节点进行Merkle证明时要向全节点请求路径哈希值**
**截至2025.3.10,区块高度已达887115,大约每10分钟生成一个新的区块(Pow保证,确保不是人人随时都可以生成新区块)**
