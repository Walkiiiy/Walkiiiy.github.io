---
title: AES
date: 2025-03-02 17:37:33
tags:
---
AES（高级加密标准）是一种**对称加密**算法，它取代了DES（Data Encryption Standard）成为现代加密的主流标准。AES 由美国国家标准与技术研究院（NIST）于 2001 年发布，广泛应用于数据加密和信息安全领域。AES 采用**分组密码**的方式，对固定长度（**128 位**）的数据块进行加密，并支持 128、192 和 256 位的密钥长度。

---
![AES](/images/AES.png)
## **基本结构**
AES 的加密过程采用 **SPN（Substitution-Permutation Network）结构**，即“**代换-置换**”网络。AES 的核心组成部分包括：
- **字节替换（SubBytes）**
- **行移位（ShiftRows）**
- **列混合（MixColumns）**
- **轮密钥加（AddRoundKey）**
- **密钥扩展（KeyExpansion）**

AES 采用**多轮迭代**的方式进行加密：
- **AES-128** 需要 **10 轮**
- **AES-192** 需要 **12 轮**
- **AES-256** 需要 **14 轮**

---

## **2.加密过程**
AES 的加密过程可以表示为：
1. **密钥扩展（Key Expansion）**
2. **初始轮（Initial Round）**
   - 轮密钥加（AddRoundKey）
3. **主轮（Main Rounds）**
   - 字节替换（SubBytes）
   - 行移位（ShiftRows）
   - 列混合（MixColumns）
   - 轮密钥加（AddRoundKey）
4. **最终轮（Final Round）**
   - 字节替换（SubBytes）
   - 行移位（ShiftRows）
   - 轮密钥加（AddRoundKey）

### **2.1 密钥扩展（Key Expansion）**
AES 的密钥扩展算法会从原始密钥生成多个**轮密钥（Round Key）**，以供每轮加密使用。扩展过程采用**Rijndael 密钥扩展算法**，根据密钥长度（128/192/256 位）生成不同数量的子密钥：
- **AES-128** 需要 **44 轮密钥（4 × (10+1)）**
- **AES-192** 需要 **52 轮密钥（4 × (12+1)）**
- **AES-256** 需要 **60 轮密钥（4 × (14+1)）**

扩展步骤：
1. **前 4 个字（128 位）直接来自密钥**
2. **后续密钥** 由前一个密钥组的变换（包括 **轮常量（Rcon）和 S 盒（S-box）替换）** 计算得出

---

### **2.2 初始轮（Initial Round）**
**AddRoundKey（轮密钥加）**
- 将明文的 128 位数据**按列组织成 4×4 的状态矩阵**（State Matrix）
- 用第 0 轮密钥（Round Key）进行**按位异或（XOR）** 操作

公式：
$$
\text{State} = \text{State} \oplus \text{RoundKey}
$$

---

### **2.3 主轮（Main Rounds）**
主轮是 AES 的核心，每轮包括以下四个步骤：

#### **(1) 字节替换（SubBytes）**
- 采用 **S-Box（替换盒）**，对每个字节进行替换（非线性变换）
- S-Box 是基于有限域 GF(2⁸) 的逆元变换和仿射变换构造的
- 目的是**增加数据的混淆性（Confusion）**

#### **(2) 行移位（ShiftRows）**
- 处理 **状态矩阵（State）** 的行：
  - **第 0 行不变**
  - **第 1 行左移 1 字节**
  - **第 2 行左移 2 字节**
  - **第 3 行左移 3 字节**
- 目的是**打乱数据位置，增强扩散性（Diffusion）**

示例：
```
初始状态：
a0 a1 a2 a3
b0 b1 b2 b3
c0 c1 c2 c3
d0 d1 d2 d3

移位后：
a0 a1 a2 a3
b1 b2 b3 b0
c2 c3 c0 c1
d3 d0 d1 d2
```

#### **(3) 列混合（MixColumns）**
- 将 **状态矩阵的每一列** 视为一个 4 维向量，与一个固定的矩阵**相乘（有限域 GF(2⁸) 乘法）**，达到**数据扩散**的目的
- 计算公式：
$$
\begin{bmatrix}
s'_0 \\ s'_1 \\ s'_2 \\ s'_3
\end{bmatrix}
=
\begin{bmatrix}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02
\end{bmatrix}
\cdot
\begin{bmatrix}
s_0 \\ s_1 \\ s_2 \\ s_3
\end{bmatrix}
$$

- **提高扩散性，使明文的每一比特影响多个比特**

#### **(4) 轮密钥加（AddRoundKey）**
- 与对应的 **轮密钥（Round Key）** 进行**按位异或（XOR）**
- 目的是提供 **密钥依赖性（Key Dependency）**

---

### **2.4 最终轮（Final Round）**
最终轮与主轮类似，**但去掉了列混合（MixColumns）**，只执行：
- **字节替换（SubBytes）**
- **行移位（ShiftRows）**
- **轮密钥加（AddRoundKey）**

最终得到 **密文（Ciphertext）**。

---

## **3. AES 加密流程总结**
1. **输入：** 128-bit 明文 + 128/192/256-bit 密钥
2. **密钥扩展：** 生成多个轮密钥
3. **初始轮**
   - 轮密钥加
4. **主轮（重复 9/11/13 轮）**
   - 字节替换
   - 行移位
   - 列混合
   - 轮密钥加
5. **最终轮**
   - 字节替换
   - 行移位
   - 轮密钥加
6. **输出：** 128-bit 密文
**AES具有良好的扩散性和混淆性**
* 混淆指明文和密文之间的关系足够复杂(非线性,通过s盒实现)
* 扩散指打散明文的结构，使明文的小变化能够影响密文的大部分(雪崩效应,列混淆实现)
## **填充**
**常见填充方法PKCS#7**:每个填充字节内均为填充字节的长度,如果明文正好是16字节,就附加一个空的16字节,每个字节值都为16.
##  **分组密码工作模式**
![分组密码工作模式](/images/BlockCipherModesofOperation.svg.png)
#### 电码本ECB
重复信息块会重复出现
#### 密码块链接CBC
随机生成向量IV,与首块异或后AES,结果向后参与异或运算.IV必须保证随机.
#### CTR计数器模式
* 使用12字节的Nonce和4字节计数器组成16字节,进入AES加密后和明文异或.Nonce要求有随机性.
* 不需要填充,可以用流密码的方式应用AES.
## AES-GCM
building...........
# 细节补充:
## **AES 的密钥长度、轮数和派生密钥数量**
AES（高级加密标准）支持 **三种不同的密钥长度**，对应不同的加密轮数和派生密钥数量：

| **AES 密钥长度** | **轮数（Nr）** | **派生的轮密钥数量（Nk, 32 位字）** | **需要派生的总密钥字数（Nb × (Nr+1)）** |
|--------------|------------|----------------|--------------------|
| **AES-128**（16 字节 = 128 位） | 10 轮 | 4（原始密钥）+ 40（扩展）= 44 | 44 个 32 位字（= 176 字节） |
| **AES-192**（24 字节 = 192 位） | 12 轮 | 6（原始密钥）+ 48（扩展）= 52 | 52 个 32 位字（= 208 字节） |
| **AES-256**（32 字节 = 256 位） | 14 轮 | 8（原始密钥）+ 56（扩展）= 60 | 60 个 32 位字（= 240 字节） |

---

## **AES 密钥派生（密钥扩展算法）**
AES 的 **密钥扩展（Key Expansion）** 采用 **Rijndael 密钥扩展算法**，主要用于从输入密钥生成所有的**轮密钥（Round Keys）**，以便在每一轮 AES 变换时使用。

### **1. 主要步骤**
密钥扩展算法主要基于**字（word）**单位进行操作，每个字是 **4 个字节（32 位）**。  

派生过程如下：
1. **将输入密钥作为初始密钥存入数组**。
2. **对剩余的字（Word）进行扩展**：
   - 每 **Nk 个字** 触发特殊变换（RotWord + SubWord + Rcon）。
   - 其余部分根据前一个字进行扩展。
3. **最终生成 Nb × (Nr+1) 个 4 字节的密钥字**，供 AES 各轮使用。

---

### **2. 详细步骤**
设 AES 密钥扩展生成的数组为 $ W[i] $，其中每个 $ W[i] $ 是一个 **4 字节（32 位）** 的字，步骤如下：

#### **（1）初始化**
- 先把原始密钥存入前 **Nk** 个字，即：
  $$
  W[i] = \text{Key}[i], \quad \text{for } 0 \leq i < Nk
  $$
  其中：
  - **Nk** 是密钥长度（128-bit = 4，192-bit = 6，256-bit = 8）。
  - 初始密钥的 **Nk 个字** 直接拷贝到密钥数组。

---

#### **（2）密钥扩展**
**对于 $ i \geq Nk $，计算 $ W[i] $**
$$
W[i] = W[i-Nk] \oplus \text{KeyExpansionFunction}(W[i-1], i)
$$
其中：
- **如果 $ i $ 是 Nk 的整数倍**，则：
  $$
  \text{KeyExpansionFunction}(W[i-1], i) = \text{SubWord}(\text{RotWord}(W[i-1])) \oplus Rcon[i/Nk]
  $$
- **如果是 AES-256 并且 $ i $ 是 4 的倍数（但不是 8 的倍数）**：
  $$
  \text{KeyExpansionFunction}(W[i-1], i) = \text{SubWord}(W[i-1])
  $$
- **否则，直接使用 $ W[i-1] $**：
  $$
  \text{KeyExpansionFunction}(W[i-1], i) = W[i-1]
  $$

---

### **3. 关键操作**
#### **（1）RotWord**
**循环左移 1 字节**（用于增加密钥的扩散性）：
$$
\text{RotWord}([a_0, a_1, a_2, a_3]) = [a_1, a_2, a_3, a_0]
$$
示例：
$$
\text{RotWord}([0x09, 0xCF, 0x4F, 0x3C]) = [0xCF, 0x4F, 0x3C, 0x09]
$$

#### **（2）SubWord**
**对每个字节应用 AES S-盒**（增加非线性）：
$$
\text{SubWord}([b_0, b_1, b_2, b_3]) = [S(b_0), S(b_1), S(b_2), S(b_3)]
$$

示例：
$$
\text{SubWord}([0xCF, 0x4F, 0x3C, 0x09]) = [S(0xCF), S(0x4F), S(0x3C), S(0x09)]
$$

#### **（3）轮常数（Rcon）**
Rcon（Round Constant）是一个 4 字节的数组，仅在 **每 Nk 轮** 进行变换时使用：
$$
Rcon[i] = [2^{(i-1)}, 0x00, 0x00, 0x00] \quad \text{在 GF(2⁸) 上}
$$
示例：
| 轮数 $ i $ | Rcon[i] (十六进制) |
|---------|--------------|
| 1       | 0x01 00 00 00 |
| 2       | 0x02 00 00 00 |
| 3       | 0x04 00 00 00 |
| 4       | 0x08 00 00 00 |
| 5       | 0x10 00 00 00 |
| 6       | 0x20 00 00 00 |
| 7       | 0x40 00 00 00 |
| 8       | 0x80 00 00 00 |
| 9       | 0x1B 00 00 00 |
| 10      | 0x36 00 00 00 |

---
