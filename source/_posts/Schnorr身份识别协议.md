---
title: Schnorr身份识别协议
date: 2025-02-28 14:57:32
tags:
---
施诺尔Schnorr身份识别协议
**证明自己掌握某值而不泄漏,即零知识证明**
* 零知识证明的根本思想在于如何证明"我知道一个东西"而不向被证明的人透露任何关于证明方法或结果的信息.而且在外界看来,不知道证明者与被证明者是否是串通好的.
* 根本方法:每次只透露使用该信息进行二次计算得来的部分结果.
* 与哈希函数的应用"承诺"有相似之处,但承诺必须验证方得到真实结果后才能验证.
## 数论基础:
**基于离散对数难题**
## 步骤:
系统选择以下公钥参数：
- **素数 $ p $ 和阶为 $ q $ 的生成元 $ g $**
  - 选择一个大素数 $ p $ 和一个阶为 $ q $ 的子群生成元 $ g $（通常在椭圆曲线上或模素数群 $ \mathbb{Z}_p^* $ 中选择）。
- **私钥 $ x $ 和公钥 $ y $**
  - 证明者选择一个随机的私钥 $ x \in \mathbb{Z}_q $。
  - 计算公钥 $ y = g^x \mod p $ 并公开。

**公钥：** $ (p, q, g, y) $

**私钥：** $ x $

---

### **(1) 证明者生成承诺 (Commitment)**
- 证明者随机选择一个临时秘密 $ r \in \mathbb{Z}_q $。
- 计算承诺值（临时公钥）：
  $$
  t = g^r \mod p
  $$
- 证明者发送 $ t $ 给验证者。

### **(2) 验证者发送挑战 (Challenge)**
- 验证者随机选择一个挑战值 $ c \in \mathbb{Z}_q $。
- 发送 $ c $ 给证明者。

### **(3) 证明者计算响应 (Response)**
- 计算响应值：
  $$
  s = r + c \cdot x \mod q
  $$
- 发送 $ s $ 给验证者。

### **(4) 验证者检查等式 (Verification)**
验证者计算：
$$
g^s \mod p
$$
并检查是否满足：
$$
g^s \equiv t \cdot y^c \mod p
$$
如果等式成立，验证通过，否则验证失败。

---

### **可靠性**
* 如果证明者确实知道私钥 $ x $，则：
$$
g^s = g^{r + c x} = g^r \cdot (g^x)^c = t \cdot y^c
$$
所以验证者一定能正确验证身份。
* 验证者想要破解x,就必须通过$ s=r+c*x $,而由于他不知道r只知道$t = g^r \mod p$,离散对数困难性让他无法反退得到r,且r每次验证时都随机选取.也就是这直线方程中只有一个参数是保持不变的.因此x无法破解.


### 为什么要用q阶子群?
* **为了避免小阶子群攻击**
### 应用场景
* 身份认证,验证者手上有证明者的公钥,证明者证明自己有私钥
* RSA也可以用于零知识证明,但其中的指数e,d通常为2048bit,Schnorr指数只要256bit.RSA为  O(log2048)而Schnorr为O(log256),根本原因是Schnorr 依赖于离散对数问题（DLP）的安全性，而 RSA 依赖于大数因子分解问题（IFP）