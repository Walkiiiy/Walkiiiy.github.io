---
title: Swapping Repair for Misplaced Attribute Values
date: 2025-04-11 11:33:07
tags:
---
**文献阅读:规范化的错位属性值修复方法**
**From"Swapping Repair for Misplaced Attribute Values" by Yu Sun, Shaoxu Song, Chen Wang, Jianmin Wang**
https://sxsong.github.io/doc/20icde.pdf
#### 总览
* 解决的问题：例如用户在填写表单时将“Passport”错误输入到“乘客姓名”属性，这种错误比较常见，如数据集成时因分隔符错误或OCR识别错误导致属性错位，传感器数据传输中因缺失值导致后续数据位移等，都会导致属性错位。
* 现有方法：现有方法往往解决的是同一属性的问题**in-attribute errors**，而不是同一元祖内的属性错位**misplaced-attribute errors**。
* 难点：直接使用相似度比对会出现合法的离群值outliner被错认为错误数据的情况。要设计一套成熟的方案，断言是否出现属性值错位，并通过元祖内交换属性值查看是否有与其他元组更高相似度的情况。
#### 距离似然评估
判断是否存在错位属性值需要修复
###### 错误的思路：通过值的概率分布计算相似度
通过实际数据集的比对就可以看出，简单通过属性值的概率分布是无法分辨outliner和错位值的（左图为属性值概率分布，右侧为使用k临近计算归一化距离）
![Fewquency_and_knn](/images/Fewquency_and_knn.png)
###### 正确的思路：k近邻算法κ-nearest-neighbors (κ- NN ) 
* 对元组$t_i$到某一近邻元组$t_j$的距离以曼哈顿距离归一化，建模：
$$ Δ(ti [R], tj [R]) = ∑Δ(ti[A], tj [A])$$
* $t_i$与其相邻元组的距离服从指数分布：
$$
f (Δ(ti , tj )) = λ e^{−λΔ(ti ,tj )}
$$
* 对k个相邻元组的概率求和并对数化可得似然函数：
  $$
  \hat{\ell}(t') = \kappa \log \lambda - \lambda \sum_{t_l \in N_\kappa(t')} \Delta(t', t_l)
  $$
  即为元组$t_0$与周围k和元组的总距离

总距离低于阈值时，交换属性值，尝试得到更高相似度方案（SRAN\SRKN\SRFN）。
**举例**：
这里直接用AI给出的工程数据举例，以便更好理解：

假设有原始数据：
| 时间   | 电压（V） | 温度（°C） | 方向（°） |
|--------|-----------|------------|----------|
| 15:40  | 13.7      | 33.3       | 330      |
| 15:35  | 22.9      | 14.0       | 5        |
| 15:30  | 24.1      | 12.5       | 358      |

通过距离计算发现15:40的元组与邻近元组（如15:35、15:30）的曼哈顿距离显著更大：
• 与15:35的距离：Δ电压= |13.7-22.9|=9.2，Δ温度= |33.3-14.0|=19.3 → 总距离=28.5
• 与15:30的距离：Δ电压= |13.7-24.1|=10.4，Δ温度= |33.3-12.5|=20.8 → 总距离=31.2

定义交换矩阵 $ x $ 表示电压（A₂）与温度（A₃）互换：
$$
x = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$$

使用归一化曼哈顿距离：
$$
\Delta_{\text{norm}}(v_1, v_2) = 1 - e^{-|v_1 - v_2|/\text{range}}
$$
• 上式是先计算距离，再归一化处理，关于曼哈顿距离可见https://www.cnblogs.com/suanfajin/p/18280761
• 电压范围=30V（10-40V），温度范围=40°C（10-50°C）。
• 修复后与15:35的电压距离：$ 1 - e^{-|33.3-22.9|/30} = 1 - e^{-0.35} \approx 0.30 $
• 总距离=0.30（电压） + 0.01（温度） + ... ≈ 0.31，显著低于修复前的0.95。

优化目标（最小化κ-NN距离）  
**若κ=2，选择最近的2个邻居（15:35和15:30）**，目标是最小化：
$$
\Theta(x) = \Delta(x t_0, t_{15:35}) + \Delta(x t_0, t_{15:30})
$$
交换修复后 $\Theta(x) = 10.7 + 10.4 = 21.1$，远低于修复前的59.7。

###### 联合修复流水线Joint Repair Pipeline
时间连续的数据集中，上下文的相关性可以用于数据纠错。但是在联合数据纠错与属性错位纠错时，要注意先进行属性错位纠错，再进行数据纠错。
#### 将所有邻元组纳入计算
当相邻元组的个数扩展到整个数据集大小r时，仍可以在多项式时间内求解最高相似度（最小距离）的交换方案，即将原问题转化为最小权重完美匹配问题minimum weight perfect matching (MWPM).
###### SRAN算法:Swapping Repair with All Neighbors
构建二分图，将每个属性视为二分图的两部分顶点集合（左部U和右部V），每个属性在U和V中各有一个节点。边权为交换属性后的总距离。
使用匈牙利算法解决该二分图的最小权重完美匹配：https://www.bilibili.com/video/BV16K4y1X7Ph/?share_source=copy_web&vd_source=275d46b9a03d7ce577d10c1f2bdb1206
**理解过程中的错误：**
文献中提到的时间复杂度为$$O(nm^2+m^3)$$其中匈牙利算法本身时间复杂度为$O(m^3)$,计算所有权重（即所有交换方案的距离值）所需的时间复杂度为$O(nm^2)$，其中n为元组数，m为属性数。
由此，对每一元组分别使用该算法所需的时间复杂度为$$O(n^2m^2+nm^3)$$,但是简单从头遍历每一元组并对其使用SRAN，显然无法保证其最优性（改变后面的属性匹配也会影响前面已经改变的，使其不再是最优），**莫非需要结合贪心策略或者动态规划？**

**原因：**
SRAN，包括后面的SRKN本身就**只是针对一个元组进行优化**的，并不是检查并修复该数据集中的所有元组。在实际应用中，是**先通过距离判断某一元组出现问题后，再使用SRAN计算其最最优纠错方案**。

#### SRKN固定邻居数量k修复算法：Fixed Number of Neighbors
注意，选取前k个和$t_0$最邻近的不一定就是最优解！
以下为具体步骤（AI总结）
**步骤1：初始化**
• 初始邻居集合：从数据集 $ r $ 中选择前κ个邻居 $ T = \{ t_1, t_2, \dots, t_κ \} $。
• 剩余集合：$ S = r \setminus T = \{ t_{κ+1}, t_{κ+2}, \dots, t_n \} $。
• 当前最优解：调用SRAN计算初始解 $ x^* = \text{SRAN}(t_0, T) $，并记录其距离成本 $ \theta^* = \Theta_T^{|T|}(x^*) $。

**步骤2：递归生成子集**
• 生成新子集：对于当前子集 $ T $ 中的每个元组 $ t_p $ 和剩余集合 $ S $ 中的每个元组 $ t_q $，生成新子集 $ T' = T \setminus \{ t_p \} \cup \{ t_q \} $。
• 更新剩余集合：$ S' = S \setminus \{ t_q \} $。

**步骤3：剪枝优化**
• 计算下界：根据Proposition 3，计算 $ T' $ 的**距离成本下界** $ \theta_{T'}^{\min} = \sum_{t_l \in T'} \theta_l^{\min} $，其中 $ \theta_l^{\min} $ 是仅考虑邻居 $ t_l $ 时SRAN的最小成本（公式10）。
• **剪枝条件**：若 $ \theta_{T'}^{\min} \geq \theta^* $，跳过该子集（无法改进当前最优解）。

**步骤4：调用SRAN并更新最优解**
• 计算子集解：若未剪枝，调用 $ x = \text{SRAN}(t_0, T') $，计算 $ \theta = \Theta_{T'}^{|T'|}(x) $。
• 更新最优解：若 $ \theta < \theta^* $，更新 $ x^* = x $ 和 $ \theta^* = \theta $。

**步骤5：递归深入**
• 递归调用：以 $ T' $ 和 $ S' $ 为参数，递归执行步骤2-4，直到遍历所有可能的κ邻居子集。

#### SRFN固定邻居集合算法
和SRKN类似，不同之处在于不枚举每一种集合，而是通过动态生成每一个元组的knn集合，生成候选集合组，在候选集合组内递归进行SRAN并剪枝优化。








