---
title: TLS
date: 2025-03-05 12:55:17
tags:
---
## TLS握手
* TLS可分为握手阶段和安全通信阶段,握手阶段主要是身份认证和密钥协商.
* TLS需要支持会话恢复,当同一客户端重复连接到同一服务器时,无需进行重复的密钥交换.
#### TLS1.3协议栈
* 密钥交换:五种曲线的ECDH,FFDH(旧版本TLS支持RSA密钥交换)
* 签名(可以各自选择不同的):RSA PKCS#1v1.5,RSA-PSS,ECDSA,EdDSA,其中的Hash算法一般选择sha-256和sha-512.
* HMAC和HKDF:使用sha-256或sha-384
* 认证加密:AES-GCM,ChaCha20-Poly1305.

#### 1>协议协商,密钥交换
* 客户端首先提供自己的协议栈ClinetHello并附上推测的密钥交换算法的公钥,服务端选择协议返回客户端ServerHello,如果客户端推测失败则需要再重新发送一次公钥.
* 随后根据选择的方法完成密钥交换,在随后的握手中全部使用对称密钥进行加密.
#### 2>服务器参数协商
#### 3>认证
* 浏览器信任证书认证机构CA的公钥(由操作系统提供).
* CA(如Let'sEncrypt)会对被认证网站的公钥进行签名(使用私钥),形成证书后下发给被认证网站服务器.
* 证书包含了自己的公钥和上级CA对自己公钥签名后的值,即用于认证证书的公钥也是证书的一部分.
* 服务器在认证阶段发送自己的公钥以及证书,还要发送一条CA证书链(即从认证CA到根CA的证书)
* 浏览器从低到高验证.
* 由于所有认证步骤都由认证加密算法加密,所以可以防止中间人截获攻击.
* 被认证后,服务器接下来发送的所有消息都会附加上使用自己公钥的签名.

**注意区分服务器证书公钥(长期)和密钥交换公钥(临时)**
#### 4>结束握手
双方通过Finished消息来结束握手.通过HMAC生成握手阶段所有消息的摘要并发送给对方,以实现完整性检测.

## 附加安全策略
* 为了防止ClientHello重放攻击,在密钥交换中双方各自生成一个随机数传给对方,真正的对称密钥是ECDH密钥和双方的随机数经过HKDF算法得到的.
$$
     MasterSecret = PRF(PreMasterSecret, "master secret", ClientRandom + ServerRandom)
$$
* 这样,即使重放ClientHello也无法得到同样的服务器端随机数,无法计算出共享密钥.
* 另外还有会话ID,时间限制等策略.



## 其它问题:
* 为什么仍可用PKCS#1v1.5签名?因为百万消息攻击(适应性选择密文攻击)无法恢复私钥,而且签名本身只是为了验证身份,即使破解了被签名的哈希值也无所谓.