---
title: TLS
date: 2025-03-05 12:55:17
tags:
---
## TLS握手
* TLS可分为握手阶段和安全通信阶段,握手阶段主要是身份认证和密钥协商.
* TLS需要支持会话恢复,当同一客户端重复连接到同一服务器时,无需进行重复的密钥交换.
#### TLS1.3协议栈
* 密钥交换:五种曲线的ECDH,FFDH(旧版本TLS支持RSA密钥交换)
* 签名(可以各自选择不同的):RSA PKCS#1v1.5,RSA-PSS,ECDSA,EdDSA,其中的Hash算法一般选择sha-256和sha-512.
* HMAC和HKDF:使用sha-256或sha-384
* 认证加密:AES-GCM,ChaCha20-Poly1305.

#### 1>协议协商,密钥交换
* 客户端首先提供自己的协议栈ClinetHello并附上推测的密钥交换算法的公钥,服务端选择协议返回客户端ServerHello,如果客户端推测失败则需要再重新发送一次公钥.
* 随后根据选择的方法完成密钥交换,在随后的握手中全部使用对称密钥进行加密.
**注意,为了防止中间人在密钥交换阶段就在拦截并修改密钥交换信息,在密钥交换阶段服务器就要对DH公钥信息使用自己的证书私钥进行签名.** 
#### 2>服务器参数协商
#### 3>认证
* 浏览器信任证书认证机构CA的公钥(由操作系统提供).
* CA(如Let'sEncrypt)会对被认证网站的公钥进行签名(使用私钥),形成证书后下发给被认证网站服务器.
* 证书包含了自己的公钥和上级CA对自己公钥签名后的值,即用于认证证书的公钥也是证书的一部分.
* 服务器在认证阶段发送自己的公钥以及证书,还要发送一条CA证书链(即从认证CA到根CA的证书)
* 浏览器从低到高验证.
* 由于所有认证步骤都由认证加密算法加密,所以可以防止中间人截获攻击.
* 被认证后,服务器接下来发送的所有消息都会附加上使用自己公钥的签名.

**注意区分服务器证书公钥(长期)和密钥交换公钥(临时)**
#### 4>结束握手
双方通过Finished消息来结束握手.通过HMAC生成握手阶段所有消息的摘要并发送给对方,以实现完整性检测.

## 附加安全策略
* 为了防止ClientHello重放攻击,在密钥交换中双方各自生成一个随机数传给对方,真正的对称密钥是ECDH密钥和双方的随机数经过HKDF算法得到的.
$$
     MasterSecret = PRF(PreMasterSecret, "master secret", ClientRandom + ServerRandom)
$$
* 这样,即使重放ClientHello也无法得到同样的服务器端随机数,无法计算出共享密钥.
* 另外还有会话ID,时间限制等策略.


##  X.509证书标准
X.509 证书的核心字段包括：
- **版本（Version）**：标明 X.509 证书的版本（常见版本为 v3）。
- **序列号（Serial Number）**：证书颁发机构（CA）分配的唯一标识。
- **签名算法（Signature Algorithm）**：指明证书所使用的签名算法，如 **RSA-SHA256**。
- **颁发者（Issuer）**：证书颁发机构（CA）的信息。
- **有效期（Validity）**：证书的生效日期和过期日期。
- **主体（Subject）**：证书持有者的信息（如域名、组织名称）。
- **公钥（Public Key）**：用于加密和身份验证的公钥。
- **扩展字段（Extensions, 仅 v3 支持）**：
  - **Key Usage**（密钥用途，如数字签名、数据加密）。
  - **Subject Alternative Name (SAN)**（允许多个域名）。
  - **Certificate Policies**（证书策略）。
  - **CRL Distribution Points**（证书吊销列表）。
  - **Authority Key Identifier**（用于链式验证）。
## 预共享密钥PSK与0-RTT
* 预共享密钥可以省略密钥交换过程和认证过程,直接通过共享标识符来生成对称密钥.结合0-RTT可以做到客户端在发送玩ClientHello后直接开始传输数据.
* 需要额外注意重放攻击.
## 其它问题:
* 为什么仍可用PKCS#1v1.5签名?因为百万消息攻击(适应性选择密文攻击)无法恢复私钥,而且签名本身只是为了验证身份,即使破解了被签名的哈希值也无所谓.