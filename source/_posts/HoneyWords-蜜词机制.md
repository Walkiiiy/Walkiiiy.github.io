---
title: HoneyWords-蜜词机制浅析
date: 2025-02-26 09:49:38
tags:
---
# HoneyWords 浅析
## 介绍（“Honeywords:Making Password-Cracking Detectable”by  Ari JuelsRonald and L. Rivest）
###  背景
* 基本的口令保护机制有加盐、蜜罐（honeypot accounts）等，都是为了抵御彩虹表类攻击。
* 加盐：常见的加盐方式为，在对密钥进行一次sha-256哈希后，拼接随机串，再进行一次md5哈希（其次序和哈希算法无关紧要）。配合使用慢哈希函数如PBKDF2，Scrypt，Argon2，能大幅增加彩虹表的构建成本和长度。但是有足够算力的攻击者拿到数据库中的随机串后，仍有可能进行暴力破解。并且并不能提供入侵检测。
* 蜜罐帐号：服务端生成一些非真实用户的蜜罐帐号，一旦检测到该蜜罐帐号的密码被尝试用于登入，就说明哈希表已经被窃取并且暴力破解。这种方法提供了比较保守的入侵检测功能，但无法保证攻击者无法区分真实帐号和蜜罐帐号，且处于被动地位，无法增加攻击的成本和风险。
### 原理
- 系统为每个用户生成一个包含 **1 个真实密码（Sugarword）+ k-1 个蜜词（Honeywords）** 的列表：
  \[
  W_i = (w_{i,1}, w_{i,2}, ..., w_{i,k})
  \]
- 其中，**仅有一个密码是用户的真实密码**，其索引值 \( c(i) \) 存储在一个**独立的安全服务器**（Honeychecker）上。
- 系统存储的是**所有蜜词及真实密码的哈希值**：
  \[
  H_i = (H(w_{i,1}), H(w_{i,2}), ..., H(w_{i,k}))
  \]
- 由于哈希值存储在系统中，而正确密码的索引 \( c(i) \) 仅存储在 Honeychecker 服务器中，即使攻击者窃取了系统中的哈希文件，也无法区分真实密码。当攻击者花费比以往高的多的攻击成本生成彩虹表后进行尝试时，只要选取的是蜜词就会触发入侵检测。
- 用户输入密码 \( g \) 进行登录，系统执行以下步骤：

1. **哈希计算**  
   - 系统计算用户输入的密码的哈希值 \( H(g) \)。
   - 在用户的哈希列表 \( H_i \) 中查找是否有匹配项：
     - **如果找不到**，拒绝登录（密码错误）。
     - **如果找到了匹配项**，进入下一步。

2. **蜜词检测（Honeychecker 交互）**  
   - 由于 \( H(g) \) 匹配用户的某个哈希值 \( H(w_{i,j}) \)，但系统无法判断 \( j \) 是否是真正的密码索引 \( c(i) \)。
   - 系统向**独立的 Honeychecker 服务器** 发送查询：
     \[
     \text{Check}(i, j)
     \]
   - Honeychecker 服务器检查 **j 是否等于 c(i)**：
     - **如果 \( j = c(i) \)（输入的是正确密码）**
       - 正常登录，允许访问系统。
     - **如果 \( j \neq c(i) \)（输入的是蜜词）**
       - **触发安全告警**（但是否允许登录可以由系统策略决定）。
       - 可以选择：
         - **直接拒绝登录**
         - **发送静默告警，观察攻击者行为**
         - **重定向到蜜罐（Honeypot）环境进行监控**

### 技术细节
* 假设攻击者无法直接获取密码明文（如使用了RSA交换）但可以获取整张在/etc/shadow或数据库中存储的哈希表，以及盐值。并且有暴力破解获取彩虹表的能力。
* 假设存在一个冗余服务器"honeyChecker"，不对外界开放接口，且之在用户登录或者修改密码时对主服务器的"set"和"check"指令进行响应。（分布式安全：即使主服务器暴露，也不会使用户密码完全暴露。）
* 即使heneychecker暴露，也只是将安全性降低到引入蜜词机制之前的水平，也就是攻击者仍需要手动破解真实哈希值。
- Still Building……