---
title: Schnorr零知识证明与数字签名浅析
date: 2025-02-27 14:07:40
tags:
---
# 施诺尔Schnorr身份识别协议
**证明自己掌握某值而不泄漏,即零知识证明**
* 零知识证明的根本思想在于如何证明"我知道一个东西"而不向被证明的人透露任何关于证明方法或结果的信息.而且在外界看来,不知道证明者与被证明者是否是串通好的.
* 根本方法:每次只透露使用该信息进行二次计算得来的部分结果.
* 与哈希函数的应用"承诺"有相似之处,但承诺必须验证方得到真实结果后才能验证.
## 数论基础:
**基于离散对数难题**
## 步骤:
系统选择以下公钥参数：
- **素数 $ p $ 和阶为 $ q $ 的生成元 $ g $**
  - 选择一个大素数 $ p $ 和一个阶为 $ q $ 的子群生成元 $ g $（通常在椭圆曲线上或模素数群 $ \mathbb{Z}_p^* $ 中选择）。
- **私钥 $ x $ 和公钥 $ y $**
  - 证明者选择一个随机的私钥 $ x \in \mathbb{Z}_q $。
  - 计算公钥 $ y = g^x \mod p $ 并公开。

**公钥：** $ (p, q, g, y) $

**私钥：** $ x $

---

### **(1) 证明者生成承诺 (Commitment)**
- 证明者随机选择一个临时秘密 $ r \in \mathbb{Z}_q $。
- 计算承诺值（临时公钥）：
  $$
  t = g^r \mod p
  $$
- 证明者发送 $ t $ 给验证者。

### **(2) 验证者发送挑战 (Challenge)**
- 验证者随机选择一个挑战值 $ c \in \mathbb{Z}_q $。
- 发送 $ c $ 给证明者。

### **(3) 证明者计算响应 (Response)**
- 计算响应值：
  $$
  s = r + c \cdot x \mod q
  $$
- 发送 $ s $ 给验证者。

### **(4) 验证者检查等式 (Verification)**
验证者计算：
$$
g^s \mod p
$$
并检查是否满足：
$$
g^s \equiv t \cdot y^c \mod p
$$
如果等式成立，验证通过，否则验证失败。

---

### **可靠性**
* 如果证明者确实知道私钥 $ x $，则：
$$
g^s = g^{r + c x} = g^r \cdot (g^x)^c = t \cdot y^c
$$
所以验证者一定能正确验证身份。
* 验证者想要破解x,就必须通过$ s=r+c*x $,而由于他不知道r只知道$t = g^r \mod p$,离散对数困难性让他无法反退得到r,且r每次验证时都随机选取.也就是这直线方程中只有一个参数是保持不变的.因此x无法破解.


### 为什么要用q阶子群?
* **为了避免小阶子群攻击**
### 应用场景
* 身份认证,验证者手上有证明者的公钥,证明者证明自己有私钥
* RSA也可以用于零知识证明,但其中的指数e,d通常为2048bit,Schnorr指数只要256bit.RSA为  O(log2048)而Schnorr为O(log256),根本原因是Schnorr 依赖于离散对数问题（DLP）的安全性，而 RSA 依赖于大数因子分解问题（IFP）

# 数字签名
## 原理
**本质是非交互式的零知识证明(KZP)**
* 对比HMAC与数字签名:
  都是用于验证身份.数字签名双方在使用前无需交换密钥.而HMAC消息认证需要对称的密钥与消息本身一同作为HMAC的输入.
### 基于Schnorr的非交互式数字签名
* 关于Schnorr的具体步骤见"**Schnorr身份识别协议**"
* 在Schnorr的过程中,让原本由验证方提供的参数c变为一次性承诺t($t = g^r \mod p$,r随机选取)和message的哈希值,由于验证方自己无法控制哈希结果,且哈系结果可被验证因此去掉了零知识证明的交互性,符合签名标准.
### RSA PKCS#1v1.5签名
* 私钥加密,公钥解密.
* 先计算消息的哈希值,进行填充后再用RSA私钥加密.
* RSA PKCS#1v1.5存在安全漏洞.
* 同时实现完整性验证和身份验证.
* 易受到适应性选择密文攻击(根据RSA的扩展性)
### RSA-PSS
* 使用PSS编码进行预处理后在进行RSA私钥加密
* 通过证明逆否命题:加入敌手能破解RSA-PSS,则他也能破解RSA,来证明自己的安全性.

**尽管RSA PKCS#1 v1.5签名被证明不安全,但是仍然被大规模使用**
**另外还有椭圆曲线签名ECDSA和先进的数字签名:EdDSA**