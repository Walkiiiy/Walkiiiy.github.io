### **SHA-256 详细介绍**

SHA-256（**Secure Hash Algorithm 256-bit**）是**安全哈希算法（SHA）**家族的一部分，由**美国国家安全局（NSA）**设计，并由**国家标准与技术研究院（NIST）**在**FIPS PUB 180-4**标准中定义。SHA-256 属于**SHA-2**系列，是当前广泛应用于密码学、区块链、数据完整性验证等领域的重要哈希算法。

---

## **1. SHA-256 的基本概念**
SHA-256 是一种 **密码学哈希函数**，它对输入数据进行不可逆的单向变换，输出固定长度（256 比特，即 32 字节）的哈希值。其核心特性包括：
- **定长输出**：无论输入大小如何，输出始终为 256 位（64 个十六进制字符）。
- **雪崩效应**：输入的微小变化会导致输出的完全不同。
- **抗碰撞性**：难以找到两个不同的输入，使得它们的哈希值相同。
- **抗篡改性**：难以从哈希值反推出原始输入。
- **高效计算**：能够快速计算哈希值。

---

## **2. SHA-256 的算法流程**
SHA-256 采用 **Merkle–Damgård 结构**，主要基于 **位运算、模加、循环移位** 等基本操作。其核心流程如下：

### **2.1. 预处理（Padding）**
SHA-256 处理的数据长度必须是 **512 比特（64 字节）**的整数倍。因此，需要对输入消息进行填充：
1. **附加“1”比特**：即 `10000000` 以确保消息长度增长。
2. **填充“0”比特**：直到消息长度模 512 余数为 448。
3. **附加原始消息长度（64-bit）**：存储原始消息的位长度，使最终数据总长度恰好是 512 的倍数。

---

### **2.2. 消息块分组**
填充后的消息被拆分成**512 比特（64 字节）**的块，每个块进一步划分为 **16 个 32-bit 字（word）**。

---

### **2.3. 扩展消息调度**
每个 512-bit 数据块进一步扩展为 **64 个 32-bit 的字**：
\[
W_t = 
\begin{cases}
M_t, & 0 \leq t \leq 15 \\
\Sigma_1(W_{t-2}) + W_{t-7} + \Sigma_0(W_{t-15}) + W_{t-16}, & 16 \leq t \leq 63
\end{cases}
\]
其中：
\[
\Sigma_0(x) = \text{ROTR}^7(x) \oplus \text{ROTR}^{18}(x) \oplus \text{SHR}^3(x)
\]
\[
\Sigma_1(x) = \text{ROTR}^{17}(x) \oplus \text{ROTR}^{19}(x) \oplus \text{SHR}^10(x)
\]
- **ROTR**(x, n) 表示对 x 进行 n 位的循环右移。
- **SHR**(x, n) 表示对 x 进行 n 位的逻辑右移（左侧补 0）。

---

### **2.4. 初始化哈希值**
SHA-256 使用以下 8 个 32-bit 的初始哈希值（来自**平方根的前 8 个素数的前 32 位**）：
\[
H_0 = 0x6a09e667, H_1 = 0xbb67ae85, H_2 = 0x3c6ef372, H_3 = 0xa54ff53a
\]
\[
H_4 = 0x510e527f, H_5 = 0x9b05688c, H_6 = 0x1f83d9ab, H_7 = 0x5be0cd19
\]

---

### **2.5. 主要迭代（主循环）**
SHA-256 使用**64 轮**的循环，每轮使用一个 32-bit 常数 \(K_t\)（来自**立方根的前 64 个素数的前 32 位**）：

每轮执行以下计算：
1. 计算临时变量：
   \[
   T_1 = H + \Sigma_1(E) + \text{Ch}(E,F,G) + K_t + W_t
   \]
   \[
   T_2 = \Sigma_0(A) + \text{Maj}(A,B,C)
   \]
2. 更新哈希值：
   \[
   H \leftarrow G, G \leftarrow F, F \leftarrow E, E \leftarrow D + T_1
   \]
   \[
   D \leftarrow C, C \leftarrow B, B \leftarrow A, A \leftarrow T_1 + T_2
   \]
其中：
- **Ch**（选择函数）：
  \[
  \text{Ch}(x,y,z) = (x \land y) \oplus (\neg x \land z)
  \]
- **Maj**（多数决函数）：
  \[
  \text{Maj}(x,y,z) = (x \land y) \oplus (x \land z) \oplus (y \land z)
  \]
- **Σ0, Σ1** 为：
  \[
  \Sigma_0(x) = \text{ROTR}^2(x) \oplus \text{ROTR}^{13}(x) \oplus \text{ROTR}^{22}(x)
  \]
  \[
  \Sigma_1(x) = \text{ROTR}^6(x) \oplus \text{ROTR}^{11}(x) \oplus \text{ROTR}^{25}(x)
  \]

---

### **2.6. 哈希值更新**
每个数据块处理完成后，累加到初始哈希值：
\[
H_i = H_i + A_i
\]
最终的 256-bit 哈希值由 \(H_0, H_1, ..., H_7\) 连接得到。

---

## **3. SHA-256 的应用**
SHA-256 主要用于：
- **区块链**（如比特币哈希运算）
- **数字签名**（如 RSA、ECDSA）
- **TLS/SSL 安全协议**
- **完整性验证**
- **口令哈希（如 PBKDF2、bcrypt、scrypt）**

---

## **4. SHA-256 安全性**
- **抗碰撞性**：目前尚未找到有效碰撞攻击（SHA-1 已被攻破）。
- **抗原像攻击**：难以从哈希值反推出原始数据。
- **抗二次原像攻击**：难以找到相同哈希值的不同输入。
- **量子计算影响**：Grover 算法可能将安全性降低至 128-bit，但仍足够安全。

---

## **5. 代码示例**
Python 计算 SHA-256：
```python
import hashlib

message = b"Hello, SHA-256!"
hash_value = hashlib.sha256(message).hexdigest()
print(hash_value)
```
输出：
```
c9a2fef9c5cb8d62dc5b0f5ff1c12e1cd4e4a56b76c8b1fc2e4bafde77109f9d
```

---

## **6. 结论**
SHA-256 是目前最广泛使用的加密哈希函数之一，提供高强度的安全保障，广泛应用于数字签名、区块链等场景。虽然未来量子计算可能会影响其安全性，但目前仍然是强大且可靠的算法。