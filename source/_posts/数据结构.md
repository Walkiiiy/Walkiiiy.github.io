---
title: 数据结构知识点纲要
date: 2025-02-22 09:14:52
tags:
---
## 线性表 
### 顺序表
####  时间复杂度
**尾部新增或查找指定下标O(1),插入或删除O(n)**
### 链表
#### 构建方式
* 头插法:与表序相反
* 尾插法:与表序相同
#### 类型
* 双链表
* 单链表
* 循环链表:循环双链和循环单链.
* 静态链表:连续空间存储值域为指针.
####  时间复杂度
**O(n)**
### 栈
**先进后出的特殊线性表**
#### 卡特兰数公式:
n个不同元素进栈时,出栈排列数为:
$$
\frac{1}{n+1}C^n_{2n}
$$
由卡特兰数公式推导而来
#### 操作 
**初始时栈顶指针S.top为-1**
进栈操作:
```c
S.data[++S.top]=x
```
#### 链栈
操作都在链表首部进行
#### 共享栈
两个顺序栈共享一个数组空间,增长方向相反.$top1-top0=1$时栈满.
#### 表达式求值
*  人工中缀表达式转后缀表达式:按运算次序加括号后,运算符移到运算数之后
*  栈转中缀为后缀
*  求值
### 队列
**先进先出的特殊线性表**
顺序存储时会出现假溢出
#### 循环队列
出队:$front=(front+1)\mod{MaxSize}$
队长:$(rear-front+MaxSize)\mod{MaxSize}$
###### 三种判断队列空满方式:
* 牺牲一个位置:$(rear+1)\mod MaxSize=front$时满,$rear=front$时空.
* 增设Size成员
* 增设tag成员
#### 链式队列
要同时增设头尾指针
#### 双端队列
两端都可进行插入和删除
### 数组与特殊矩阵
数组是线性表推广,可以有多维,数据类型要相同,存储时行优先.
* 对称矩阵压缩存储
* 下三角矩阵压缩存储
* 上三角矩阵压缩存储
* 三对角矩阵(带状矩阵)压缩存储
* 稀疏矩阵压缩存储(三元组方式)
### 串的模式匹配
即求子串的位置
暴力求解,最坏时间复杂度为O(mn)
#### KMP算法
* 若已经匹配成功的前缀中的部分后缀正好是模式串(即字串)的前缀,则匹配失败时直接将模式串滑动到与这些相等字符对其的位置.
* 模式串失配后滑动到第几位只与模式串本身有关.
## 树与二叉树
#### 树性质
* 度为$m$的树第$i$层最多$m^i-1$个结点
* 高度为$h$的$m$叉树最多$\frac{m^h-1}{m-1}$个节点
* 度为m,n个节点的树的最小高度为$\lceil\log_m[n(m-1)+1]\rceil$
* 度为$m$,$n$个节点的树最大高度为$n-m+1$
* 节点总数=度数和+1=边数+1
#### 存储结构
* 双亲表示,值域为双亲下表
* 孩子表示,一个节点一个孩子链表
* 孩子兄弟表示,将树转为二叉树后用二叉链表表示
#### 遍历
* 先根遍历:与转为二叉树后先序遍历序列相同
* 后根遍历:与转为二叉树后中序遍历序列相同
#### 二叉树
###### 基本性质
* 满二叉树
* 完全二叉树:节点$i$所在层次$\lfloor\log_2i\rfloor+1$,左孩子为$2i$右孩子$2i+1$
* 使用二叉链表存储时,$n$个节点有$n+1$个空链域.
* 先序遍历,中序遍历,后序遍历,层序遍历只有包含中序遍历的两种以上序列才能唯一确定一棵二叉树.
#### 哈夫曼树
**总带权路径长度最小的二叉树**
* 每次选择最小的两个节点放在右下构成新节点
* 哈夫曼编码：一个码不能是另一个码的前缀
#### 并查集
同一根节点的元素属于同一集合
* 根节点的值为负的节点的个数
* 用数组存储，下标为元素名，值为指向父节点的指针
* 优化方式1：合并时让小树指向大树，优化前O(n)，优化后$O(\log_2n)$，最差为二叉树
* 优化方式2:搜索根节点时，若上一节点非根，递归的将本节点、上一节点挂载到根节点。
## 图
### 基本概念性质
* 连通分量：无向图中的极大连通子图
* 强连通分量：有向图中的极大强连通子图
* 稀疏图：$E<\lvert{V}\rvert \log\lvert{V} \rvert $
* 简单路径、回路：顶点不重复出现
* 无向图度数之和等于边数两倍
### 存储结构
* 邻接矩阵：唯一表示
* 邻接表：类似树的孩子表示，无向图每条边要表示两次
* 十字链表：适用于有向图
* 邻接多重表：适用于无向图
### 遍历
* 广度优先遍历BFS，空间复杂度O(V),时间复杂度:邻接矩阵存储$O(V^2)$，邻接表存储$O(V+E)$。稠密图使用邻接矩阵存储。
* 深度优先遍历DFS，需要递归工作栈，空间O(V),时间邻接表存储$O(V+E)$,邻接矩阵$O(V^2)$
### 最小生成树
* Prim算法 关注顶点，时间复杂度$O(V^2)$，适合稠密图。
* Kruskal算法 关注边，用并查集确保无回路，用堆存放边集，时间复杂度$O(E\log_2E)$
###  最短路径
* BFS，单源点到其他点的路径
* Dijkstra算法，单源点到其他点的路径，只适用于正权值，时间$O(V^2)$
*  Floyd算法，矩阵投影法，所有点到所有点最短路径。不能有负权值的回路。时间O(V^3)。
### 其他应用
* 有向无环图存储表达式：避免二叉树存储时的重复表达
* 拓扑排序
* 关键路径
## 查找
### 顺序查找
### 折半查找 
$mid=\lfloor(low+high)/2\rfloor$
时间$O(\log_2n)$
### 分块查找
块间有序，块内无序。
### 二叉排序树

- 若左子树不为空，则左子树上所有节点的值均小于根节点的值；  
- 若右子树不为空，则右子树上所有节点的值均大于根节点的值；  
- 左右子树也分别为二叉排序树。  

查找、插入、删除操作平均时间复杂度为 O(log n)。当输入数据接近有序时，BST 可能退化成链表，最坏时间复杂度变为 O(n)。

### 平衡二叉树 AVL

为了解决 BST 退化的问题，AVL 树引入了**平衡因子**，即每个节点左子树和右子树的高度差不超过 1。  
当插入或删除导致失衡时，通过**旋转操作**（左旋、右旋、左右旋、右左旋）来恢复平衡。


### 红黑树

红黑树是另一种自平衡的二叉搜索树，相较 AVL 树更加**“懒惰”**，它在维护平衡时对旋转的要求较宽松，因此在频繁插入/删除场景下更高效。

**性质**（红黑性质）：
1. 节点是红色或黑色；
2. 根节点是黑色；
3. 每个叶子节点（NIL）是黑色；
4. 每个红色节点的子节点都是黑色；
5. 任意节点到其所有叶子节点路径上的黑色节点数相同。

**用途**：Linux 内核、C++ STL 的 `map` 和 `set`、Java 的 `TreeMap` 等都使用红黑树。

### B树（Balanced Tree）

**特点**：
- 每个节点可以有多个关键字和多个子树；
- 所有叶子节点在同一层；
- 插入和删除不会频繁地导致节点移动；
- 相较二叉树，**减少了磁盘IO的次数**。

**阶（order）**：B树的阶表示每个节点最多可以有几个子树。例如，m 阶 B 树的每个节点最多有 m 个孩子，最多 m−1 个关键字。
### B+树


**区别于 B 树**：
- 所有的关键字都存在叶子节点中，非叶子节点只存储索引；
- 叶子节点通过指针**顺序链接**，提高区间查询效率；
- 非叶子节点不存实际数据，只用于引导搜索路径。

**应用**：B+树是大多数数据库（如 MySQL 的 InnoDB 引擎）索引结构的首选。

### 散列表
##### 常用散列函数
* 直接定址
* 除留余数
* 数字分析：取中间几位做下标 
* 平方取中：平方后取中间几位，让结果与每一位都有关
###### 冲突处理
* 开放定址：线性探测法，平方探测法，伪随机序列法
* 拉链法：类似邻接表

装填因子$\alpha=记录数n/表长m$
## 排序
- 内部排序
  - 插入排序
    - 直接插入：稳定，O($n^2$)
    - 折半插入:稳定，O($n^2$)
    - 希尔排序:不稳定，O($n^{1.3}-n^2$)
  - 交换排序
    - 冒泡排序:稳定，O($n^2$)
    - 快排:不稳定，O($n\log_2n$)
  - 选择排序
    - 简单选择:不稳定，O($n^2$)
    - 堆排序:不稳定，O($n\log_2n$)
  - 归并排序:稳定，O(n$\log_2n$)
  - 基数排序:稳定，O(d(n+r))
  - 记数排序:稳定，O(n)
- 外部排序（多路归并排序）   
