## 9.18
- arctic promptå¯¹é½ä¸å®Œå…¨ï¼Œschemaçš„é—®é¢˜ï¼Œaccè¿˜æ˜¯ä¸èƒ½å¤çº¿
- è®¨è®ºï¼šè’¸é¦deepseek/å¾®è°ƒqwen3 ï¼ˆå¯è€ƒè™‘å¤ç°Arctic?ï¼‰åšgeneratorï¼Œæ•ˆæœå®åœ¨ä¸è¡Œå†è°ƒapi
- ä¸è¡Œä¸­é—´éƒ¨åˆ†ç”¨å¤ç°çš„birdå¼€æºæ¨¡å‹

## 9.19
- qwen3 14båŸºå‡†æµ‹è¯•
- qwen3 8båŸºå‡†æµ‹è¯•
- åˆ†æArcticï¼šä¸ºä»€ä¹ˆè·‘ä¸é€š
- qwen3 8b generatorå¾®è°ƒ
- ç•¥è¯»sigmod text2sqlæ–‡çŒ®ï¼šä¸ä¸€å®šæå‡ºå¤æ‚method
- åˆ›æ–°ç‚¹ä¸å¤Ÿï¼šå¤šé˜…è¯»è®ºæ–‡ï¼Œç»“æ„å’Œæ–¹æ³•å¯ä»¥æ”¹
- å¹¶è¡Œï¼šè°ƒæ¨¡å‹ï¼Œä¼˜åŒ–åˆ›æ–°æ€§
- å®éªŒ:ä¸ä»…è¦è®¾è®¡ruleså¯¹æ¯”ï¼Œè¿˜è¦è®¾è®¡åŠ chainå’Œæ²¡æœ‰chainçš„å¯¹æ¯”
- åº”è¯¥æ˜¯ä»åå¾€å‰è®­ç»ƒï¼š
  - ç”Ÿæˆå¯ç”¨çš„generatorè®­ç»ƒææ–™ï¼šè‡ªç„¶è¯­è¨€æ­¥éª¤ã€‚å¾®è°ƒgeneratorç”Ÿæˆç›®æ ‡sqlèƒ½åŠ›
  - ç”¨è‡ªç„¶è¯­è¨€æ­¥éª¤åæ¨å®Œæ•´çš„é—®é¢˜è§£æï¼Œç”Ÿæˆå¯ç”¨çš„parserè®­ç»ƒææ–™ï¼Œå¾®è°ƒè®­ç»ƒparserç”Ÿæˆé—®é¢˜è§£æèƒ½åŠ›
  - ç”¨åæ¨å¾—åˆ°çš„ææ–™ï¼ˆé—®é¢˜è§£æå’Œè‡ªç„¶è¯­è¨€æ­¥éª¤ï¼‰å¾®è°ƒplannerç”Ÿæˆè‡ªç„¶è¯­è¨€æ­¥éª¤èƒ½åŠ›
  - æ•´ä½“æµ‹è¯•
- ç”Ÿæˆå¯ä»¥è€ƒè™‘ç”¨rules-extractionç±»ä¼¼æ–¹æ³•ï¼Œå¤šè½®æ¯”å¯¹æå–-æ”¹è¿›ï¼Œç¡®ä¿ç”Ÿæˆæ­£ç¡®å†…å®¹




## 9.20
- sql2plan prompt:
  ```
  You are a precise translator that converts an SQL query into a step-by-step natural-language execution plan.  
  Your job: given one SQL query, output a numbered list of steps describing exactly how to execute that query so someone (or another program) can reconstruct the SQL from the description. Accuracy is the top priority. The plan **must not use SQL keywords** (for example: select, from, where, join, group, having, order, limit, distinct, union, intersect, except, exists, in, subquery, alias, as) in the plan itself. Use only ordinary English and precise descriptions.

  Strict rules:
  1. Output only the numbered plan (one step per line). Do not include commentary, extraneous explanation, or the original SQL. If the SQL is invalid, output a single numbered step that clearly states the error in plain language.
  2. Preserve table and column names exactly as they appear in the SQL. When referencing them inside steps, put each name in square brackets like [table] or [table.column] so names remain unambiguous.
  3. If the query creates intermediate result sets (derived tables / nested queries), label them explicitly as "intermediate set 1", "intermediate set 2", etc., and describe exactly how each intermediate set is produced and what columns it contains.
  4. For filters, use exact logical conditions in plain English, e.g. "keep rows where [age] is greater than 30" or "keep rows where [status] is 'active' and [score] >= 80".
  5. For combining rows from multiple tables, describe the combination as: "combine rows from [A] and [B] where [A.col] equals [B.col]" and explicitly state the semantics:
    - If only matching pairs are kept, say: "keep only combinations that have a match in both sides."
    - If all rows from the left side are kept even when there is no match, say: "keep all rows from [left table]; when there is no matching row on the right, leave right-side columns empty."
    - If all rows from the right side are kept, describe symmetrically.
  6. For aggregation, avoid the phrase "group by". Instead say: "for each unique value of [column(s)] do the following: compute ..." and list aggregates precisely, e.g. "count of non-empty [id]" or "sum of [amount]" or "average of [duration]". If a filter applies to those aggregated results, say: "after computing those per-value results, keep only those groups where ...".
  7. For duplicate elimination, say: "remove duplicate rows so that values of [column list] are unique".
  8. For ordering and limiting, say: "sort the final rows by [column] from smallest to largest (or largest to smallest). Then take the first N rows" â€” be explicit about whether sorting happens before or after limiting.
  9. For computed columns or expressions, write the formula in plain math/word form, e.g. "create a new column named 'ratio' equal to [col_a] divided by [col_b]".
  10. For boolean logic, express it with plain words ("and", "or", "not") and use parentheses language if needed: "apply both conditions (A and B)".
  11. For correlated checks that depend on each row (existence checks), describe them as: "for each row in [X], check whether there exists at least one row in [Y] such that ...; keep those rows where the check succeeds."
  12. For set operations (union / intersect / except), describe them in plain terms: "produce rows that are present in either set A or set B (without duplicates)" or "produce rows present in A that are not present in B", etc.
  13. For window functions, describe partitioning and ordering in plain English and the computed window metric, e.g. "for each partition defined by [col], compute the running total of [amount] ordered by [date]" and whether the metric is attached to every row or only used for filtering.
  14. If query uses naming shortcuts (aliases), show both the original name and the shortcut once, e.g. "[employees] (called E)" and thereafter you may refer to the shortcut in square brackets like [E.id], but still preserve the link to the original.

  Output format example (must follow this style exactly):

  1. Start with all rows from [people].
  2. Keep only rows where [age] is greater than 30.
  3. For each remaining row, take the values of [name] and [age].
  4. Sort those rows by [age] from largest to smallest.
  5. Return the first 5 rows.

  Do not use any SQL keywords inside the steps. Be concise but exact. Now convert the SQL query below into the required plan (replace the SQL delimiter with the actual SQL):

  -----SQL START-----
  <PUT THE SQL QUERY HERE>
  -----SQL END-----
  ```
- å…ˆç”Ÿæˆæ²¡æœ‰ç‰¹æ®Štokençš„planåšgeneratorè®­ç»ƒï¼Œç„¶ååŠ å…¥tokens
- ä¹‹å‰çš„æ­£ç¡®ç‡ä½å¾ˆæœ‰å¯èƒ½æ˜¯å› ä¸ºLLMClient.chatæ²¡å†™å¥½

## 9.21
- åˆæˆæ•°æ®é›†ï¼šsql2text qwen3 8b
- å¦‚æœè¦åœ¨è®­ç»ƒæ–¹æ³•ä¸Šæœ‰åˆ›æ–°ï¼Œåˆ›æ–°ç‚¹éœ€è¦å¯¹text2sqlä»»åŠ¡æœ‰é’ˆå¯¹æ€§
- è¯»è¯»è®ºæ–‡
  - Dail-SQL ä¼˜åŒ–æ•°æ®é›†æ˜ å°„ï¼Œä½¿ç”¨ä¼˜åŒ–åçš„è®­ç»ƒé›†è®­ç»ƒå·²æœ‰çš„æ¨¡å‹ï¼Œç„¶ååœ¨ä¼˜åŒ–åçš„æµ‹è¯•é›†ä¸Šæµ‹è¯•ï¼Œæ¨¡å‹èƒ½åŠ›æå‡
  - 
- æ–¹æ¡ˆ1:è‡ªè®­ç»ƒ
- æ–¹æ¡ˆ2:GRPO
- æ–¹æ¡ˆ3:è°ƒapi
- æˆ–è€…æ”¹æ–¹æ¡ˆ



- ä¿®æ”¹ç»“æ„
- æ˜¯ä¸æ˜¯ä¸èƒ½æ‹¿Arcticæ¥æ”¹è¿›ï¼Ÿè¦æ„å»ºè‡ªå·±çš„ppe

- æŠŠparser-planner-excuteåˆå¹¶æˆä¸€ä¸ªæ¨¡å‹å…·ä½“è®­ç»ƒæ–¹æ³•ä»¿ç…§self-rag
  - å…·ä½“æ–¹æ¡ˆï¼š
  - æ˜¯å¦èƒ½è€ƒè™‘ä½¿ç”¨apiåˆæˆå°‘é‡è®­ç»ƒæ•°æ®
  - åˆ†ä¸ºä¸‰ä¸ªæ¨¡å‹çš„è®­ç»ƒé‡å¤ªå¤§ï¼Œè€Œä¸”å¯¹äºå°æ¨¡å‹æ¥è¯´æŠŠè®¡åˆ’å’Œæ‰§è¡Œåˆ†å¼€åè€Œä¼šé™ä½æˆåŠŸç‡ï¼Œäº‹å®ä¸ŠçŸ¥è¯†ç®€å•çš„sqlè½¬planå†è½¬å›sqlï¼ŒQwen3 8Båœ¨Birdä¸Šåªæœ‰40ä¸åˆ°çš„æˆåŠŸç‡ã€‚

## 9.22
- ä¹‹å‰æå‡ºçš„æ¶æ„å¤ªå¤§å¤ªåˆ†æ•£ï¼Œå¯¼è‡´éš¾ä»¥å®é™…è®­ç»ƒéƒ¨ç½²ï¼Œæ— ä»ä¸‹æ‰‹
- **åˆ›æ–°ç‚¹æ˜¯ç¼ºå°‘åœ¨motivationè¿˜æ˜¯è§£å†³æ–¹æ³•ï¼Ÿ**
  
- **motivation** åœ¨è¾“å…¥questionè¶³å¤Ÿæ˜ç¡®çš„å‰æä¸‹ï¼ŒLLMå¤§éƒ½èƒ½ç»™å‡ºæ­£ç¡®çš„æŸ¥è¯¢æ€è·¯ã€‚ä½†ç°æœ‰text2sqlä»å­˜åœ¨é—®é¢˜ï¼š
  - 1.**æ— æ³•ç†è§£questionçš„éšå«ä¿¡æ¯**ã€‚ä¼ ç»Ÿæ–¹æ³•é€šè¿‡ç»™question-sql pairåŠ ä¸Šä¸€å¥æ‰©å±•definationï¼ˆdefinational external knowledgeï¼Œä¹Ÿå°±æ˜¯Birdä¸­çš„evidenceï¼Œ A refers to Bï¼Œ C=...ï¼‰æ¥è§£å†³ï¼Œä½†æ˜¯**è¿™æå¤§å‰Šå¼±äº†å®é™…åº”ç”¨æ—¶çš„é²æ£’æ€§**
  - 2.questionç†è§£æ­£ç¡®ï¼ŒæŸ¥è¯¢æ€è·¯ä¹Ÿæ­£ç¡®ï¼Œä½†**æ‰§è¡Œæ–¹å¼ä¸é¢„æœŸä¸ç¬¦**ã€‚å¸¸è§çš„å°±æ˜¯å¿½ç•¥/ä¸è€ƒè™‘schemaçš„ç‰¹æ®Šç»“æ„ï¼Œä»¥å•ä¸€çš„ç»éªŒåŒ–æŸ¥è¯¢æ–¹å¼æ¥å†™sqlã€‚ä¼ ç»Ÿçš„è§£å†³æ–¹æ³•æ˜¯é€šè¿‡éšå¼çš„operational external knowledgeæå–ï¼š
    - ï¼ˆ1.schema-linkingï¼Œé€šè¿‡å‘é‡ç›¸ä¼¼åº¦/minhashç­‰ç®—æ³•ï¼Œç­›é€‰ç›¸å…³æ€§å¼ºçš„schemaä¿¡æ¯å’Œå…·ä½“å€¼æ¥è¾“å…¥ï¼Œçªå‡ºschemaé‡ç‚¹ç»“æ„ä¿¡æ¯ï¼Œä»éœ€è¦æ¨¡å‹è‡ªå·±æŒ–æ˜å‘ç°é‡ç‚¹ä¿¡æ¯
    - ï¼ˆ2.RAG-SQLï¼Œä»å¤§é‡exampleæ–‡æ¡£ä¸­æŠ½å–ç›¸ä¼¼ç¨‹åº¦é«˜çš„quesiton-sql pairï¼ŒåŠ å…¥promptä¾›æ¨¡å‹å­¦ä¹ ã€‚è¿™ç§æ–¹æ³•éå¸¸ä¾èµ–ç›¸ä¼¼æ€§ï¼Œç¼ºå°‘ç›¸ä¼¼sqlæˆ–è€…ç›¸ä¼¼åº¦æ¯”è¾ƒç®—æ³•éƒ½æ˜¯å…¶ç“¶é¢ˆ
    - ï¼ˆ3.æ¯”å¯¹å­¦ä¹ ã€åå¥½å­¦ä¹ ï¼Œå’Œæ–¹æ³•2ç±»ä¼¼ï¼ŒæŠ½å–ç›¸å…³æ€§å¼ºå’Œç›¸å…³æ€§å¼±çš„question-sqlå¯¹ï¼Œæ¥è®­ç»ƒæ¨¡å‹å‘é£æ ¼ç›¸ä¼¼çš„è¾“å‡ºé è¿‘ï¼Œå¹¶è¿œç¦»ç»“æ„ç›¸å¼‚çš„sqlè¾“å‡º
    **è€Œä¸”ä¸Šè¿°æ–¹æ³•éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„é—®é¢˜å°±æ˜¯å¯è§£é‡Šæ€§å¼±** 
  - 3. æ€è·¯å’Œæ‰§è¡Œæ–¹å¼éƒ½æ­£ç¡®ï¼Œä½†**æŸ¥è¯¢ç»“æœè¾“å‡ºçš„æ–¹å¼å’Œé£æ ¼ä¸é¢„æœŸä¸ç¬¦**ã€‚åœ¨ä¸¥æ ¼çš„æµ‹è¯•ç¯å¢ƒæˆ–è€…æŒ‘å‰”çš„ç”¨æˆ·èƒŒæ™¯ä¸‹ï¼Œè¿™æ ·çš„è¾“å‡ºå…¨éƒ¨åˆ¤é”™ã€‚ä»¥å¾€çš„ç ”ç©¶å¤šå¿½ç•¥è¿™ä¸€ç‚¹ï¼Œé‡ç‚¹è®­ç»ƒæ¨¡å‹æ ¹æ®questionå’Œschemaåˆ¶å®šæŸ¥è¯¢ç­–ç•¥ï¼Œå¿½ç•¥å…¶è¾“å‡ºå½¢å¼

- **contribution**
  - æå‡ºtext2sqlçš„å¯è§£é‡ŠNL rulesï¼Œå°†definationalå’Œoperationalçš„external knowledgeç»Ÿä¸€ä¸ºè‡ªç„¶è¯­è¨€è§„åˆ™
  - æå‡ºåŸºäºç›¸ä¼¼æ€§çš„å¯è§£é‡Šè§„åˆ™æ¨ç†æ¨¡å‹Rule Assumerï¼ˆè®­ç»ƒæ–¹æ³•åˆ›æ–°
  - ï¼ˆæå‡ºagenticè§„åˆ™éªŒè¯æ¨¡å—Rule Verifier
  - å®éªŒè¯æ˜å¯è§£é‡Šçš„ç»Ÿä¸€ç‰¹å¾æ¨ç†å¯ä»¥å¢å¼ºtext2sqlæ•ˆæœ

- **Methodology**
  - å›¾
  - å››ä¸ªæ¨¡å—ï¼šparse-plan-executor,definational_assumer,operational_assumer,verifier
  - é—®é¢˜ï¼šæœ€æœ‰è¯´æœåŠ›çš„æ¡†æ¶å’Œå®éªŒæ–¹å¼æ˜¯ä»€ä¹ˆ

- **Training**
  - parser-planner-executor
    - æ–¹æ¡ˆ1åˆ†å¼€è®­ç»ƒ
      - è‡ªè®­ç»ƒè¯­æ–™ç”Ÿæˆï¼šä»åå¾€å‰ä¾æ¬¡æ¨å¯¼ï¼šsql-->plan---ï¼ˆ+ question+ sqlï¼‰--->deteiled question
      - æ¯ä¸€æ­¥è¦ä¿è¯ç”Ÿæˆçš„planèƒ½è¢«è¿˜åŸä¸ºsqlï¼Œä½†æ˜¯ç›®å‰æ•ˆæœä¸ä½³
      - å¯ä»¥ç®€å•æ”¹è¿›ï¼Œè¯•è¯•è‡ªè®­ç»ƒ+å¾ªç¯çº é”™æ•ˆæœï¼Œä½†æ˜¯æ„Ÿè§‰æ„ä¹‰ä¸å¤§
      - åé¢è¿˜è¦åˆ†æå“ªäº›åœ°æ–¹æ’å…¥rulesï¼Œç”¨åˆ°äº†å“ªäº›rulesï¼Œæ·»åŠ ç‰¹æ®Štokenï¼ˆself-ragæ–¹æ³•ï¼‰ã€‚å¤§æ¦‚ç‡å¿…é¡»è¦apiè·å–è®­ç»ƒè¯­æ–™
    - æ–¹æ¡ˆ2
      - ä¸‰æ­¥å½“ä½œæ•´ä½“ä¸€èµ·è®­ï¼Œ å€Ÿé‰´Arcticå¼ºåŒ–å­¦ä¹ æ–¹æ³•ï¼Œéš¾åº¦å¤§ä¸ä¿è¯æ•ˆæœ
- **Experiment**




- rulesåˆ†ç±»ï¼šglobal rules å…³é”®è¯ï¼š quesiton calculate refer answering
- global Assumerè®­ç»ƒææ–™


## 9.23
- æµ‹è¯•golbalAssumer ä¸€è½®Spiderä¸‰è½®Bird 100æ¡ bird_dev
  - ğŸ“Š FINAL RESULTS:
  With Rules:
    Correct Answers: 33
    Failed Executions: 0
    Accuracy: 0.330 (33.0%)
  Without Rules:
    Correct Answers: 37
    Failed Executions: 0
    Accuracy: 0.370 (37.0%)

  ğŸ¯ IMPROVEMENT:
      Rules provide -0.040 (-4.0%) accuracy improvement
      âŒ Rules hurt performance!
- æµ‹è¯•globalAssumer ä¸€è½®Spiderä¸‰è½®Bird 100æ¡ bird_dev
  - 
  ```
  ğŸ“Š FINAL RESULTS:
  With SFT Rules:
    Correct Answers: 33
    Failed Executions: 0
    Accuracy: 0.330 (33.0%)
  With Dataset Rules:
    Correct Answers: 55
    Failed Executions: 0
    Accuracy: 0.550 (55.0%)
  Without Rules (Baseline):
    Correct Answers: 33
    Failed Executions: 0
    Accuracy: 0.330 (33.0%)

  ğŸ¯ IMPROVEMENTS:
    SFT Rules vs No Rules: +0.000 (+0.0%)
    Dataset Rules vs No Rules: +0.220 (+22.0%)
    SFT Rules vs Dataset Rules: -0.220 (-22.0%)

  ğŸ† ANALYSIS:
      â– SFT rules have no effect on performance
      âœ… Dataset rules help improve performance over baseline!
      ğŸ“š Dataset rules perform better than SFT rules!      
      ```
- æµ‹è¯•ä¸­assumed ruleså‡ºé”™è€Œè‡ªå¸¦ruleså¯¹çš„sampleï¼š
  ```
  Database: toxicology
Question: List all carcinogenic molecules and their elements.
Ground Truth: SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'

ğŸ¤– Step 1: Generating rules with fine-tuned model...
Generated Rules:
Rule 1:
Condition: When the question asks for elements of molecules
Operation: use "T1.element" from the "atom" table instead of "element" from the "molecule" table.

ğŸ“‹ Step 2: Extracting dataset definitional rules...
Dataset Rules:
Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "T2.label = '+'" in schema.

Condition: When the question mentions "carcinogenic"
Operation: use T2.label = '+' as the condition for carcinogenic molecules

Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "molecule label = '+' in schema".

Condition: When answering about "carcinogenic molecules and their elements"
Operation: make sure the output order: T2.molecule_id, T1.element

Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "T2.label = '+' in schema"

Condition: When the question asks for "distinct molecules"
Operation: compute the number of unique values of T2.molecule_id

Condition: When the question mentions "carcinogenic"
Operation: "carcinogenic" actually means "label in schema" with values like '+' and '-'.
  ``` 
  ```
  Sample 91/100
  Database: california_schools
  Question: For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?
  Ground Truth: SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1

  ğŸ¤– Step 1: Generating rules with fine-tuned model...
  Generated Rules:
  Rule 1:
  Condition: When the question asks for the school with the highest average score in Reading
  Operation: use the "AvgScrRead" column from the "satscores" table to determine the highest score.

  ğŸ“‹ Step 2: Extracting dataset definitional rules...
  Dataset Rules:
  Condition: When answering about "school with the highest average score in Reading"
  Operation: rank schools by T1.AvgScrRead in descending order and keep the first 1 row.

  Condition: When the question asks for "FRPM count for students aged 5-17"
  Operation: use the exact column T2."FRPM Count (Ages 5-17)" instead of FRPM_5_17.
  ```
  ```
  ğŸ¤– Step 1: Generating rules with fine-tuned model...
  Generated Rules:
  Rule 1:
  Condition: When the question asks for race dates
  Operation: select "date" from the "races" table instead of "race_date" from "formula_1".

  ğŸ“‹ Step 2: Extracting dataset definitional rules...
  Dataset Rules:
  Condition: When answering about Formula 1 race dates on Barcelona-Catalunya circuit
  Operation: make sure the output order: T2.date

  Condition: When the question mentions "Barcelona-Catalunya circuit"
  Operation: "Barcelona-Catalunya" actually means "T1.name = 'Circuit de Barcelona-Catalunya'" in schema
  ```

- æ”¹è¿›ï¼šè®­ç»ƒæ—¶å»æ‰æ²¡æœ‰definational rulesçš„æ•°æ®
- å¯ä»¥å…ˆè¯•è¯•ç”¨qwen å‡ç¼©definational rulesï¼Œä¾¿äºä½œä¸ºlableã€‚ä¸ç„¶lableé•¿åº¦ä¸ä¸€å®šè€Œä¸”å«æœ‰é‡å¤å¤§é‡æ— ç”¨çš„ä¿¡æ¯



## 9.24
- 
